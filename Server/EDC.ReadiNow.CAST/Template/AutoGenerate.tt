<#@ 
template debug="false" hostspecific="true" language="C#" #><#@ 
output extension=".cs" #><#@ 
assembly name="System.Core" #><#@ 
assembly name="System.Xml" #><#@ 
assembly name="System.Xml.Linq" #><#@ 
import namespace="System" #><#@ 
import namespace="System.Collections.Generic" #><#@ 
import namespace="System.IO" #><#@ 
import namespace="System.Linq" #><#@ 
import namespace="System.Reflection" #><#@ 
import namespace="System.Text" #><#@ 
import namespace="System.Xml.Linq" #><#@ 
import namespace="Microsoft.VisualStudio.TextTemplating" #><# 
XDocument doc = XDocument.Load(Host.ResolvePath("..\\..\\ApplicationCache\\CAST.xml"));

var published = Auto.GetPublished(doc);

foreach(var t in Auto.GetTypes(doc))
{
	var name = t.Name.Replace(" ", "");
	var file = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "Model\\" + name + ".cs"); #>
// Copyright 2011-2016 Global Software Innovation Pty Ltd

namespace EDC.ReadiNow.CAST.Template.Model
{
	/// <summary>
    /// This class was auto-generated by a templating tool against the
	/// CAST application file marked as published on '<#=published#>'.
    /// </summary>
	public static class <#=name#>Schema
	{
		//
		// <#=t.Name#>
		//
		public const string <#=name#>Type = "<#=t.Alias#>";
		
		//
		// Name
		//
		internal static string NameField
        {
            get { return "core:name"; }
        }<#
	foreach (var f in t.Fields)
	{ #>

		
		//
		// <#=f.Name#>
		//
		internal static string <#=Auto.GetSafeName(f.Name)#>Field
        {
            get { return "<#=f.Alias#>"; }
        }<# 
	}
	foreach (var r in t.Relationships)
	{ #>


		//
		// <#=r.Name#>
		//<#
		var relName = Auto.GetSafeName(r.To);
		var relAlias = r.Alias;
		var relSuffix = "Relationship";
		if (r.Reverse) {
			relName = Auto.GetSafeName(r.From ?? r.To);
			relAlias = r.ReverseAlias ?? r.Alias;
			if (r.Cardinality == "oneToOne" || r.Cardinality == "oneToMany") {
				relSuffix = "Lookup";
			}
		} else {
			if (r.Cardinality == "manyToOne" || r.Cardinality == "oneToOne") {
				relSuffix = r.Enum ? "Enum" : "Lookup";
			}
		} #>

		internal static string <#=relName + relSuffix#>
        {
            get { return "<#=relAlias#>"; }
        }<#
	} #>

	}
}<#
	File.WriteAllText(file, GenerationEnvironment.ToString());
	GenerationEnvironment.Clear();
}
foreach (var e in Auto.GetEnums(doc))
{
	var name = e.Name.Replace(" ", "");
	var file = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "Model\\" + name + ".cs"); #>
// Copyright 2011-2016 Global Software Innovation Pty Ltd

namespace EDC.ReadiNow.CAST.Template.Model
{
	/// <summary>
    /// This class was auto-generated by a templating tool against the
	/// CAST application file marked as published on '<#=published#>'.
    /// </summary>
	public static class <#=name#>Schema
	{
		//
		// <#=e.Name#>
		//
		public const string <#=name#>Type = "<#=e.Alias#>";

		//
		// Name
		//
		internal static string NameField
        {
            get { return "core:name"; }
        }<#
	foreach (var v in e.Values)
	{ #>


		//
		// <#=v.Name#>
		//<#
		var enumName = Auto.GetSafeName(v.Name); #>

		internal const string <#=enumName#>Enum = "<#=v.Alias#>";<#

	} #>

	}

	/// <summary>
    /// This enum was auto-generated by a templating tool against the
	/// CAST application file marked as published on '<#=published#>'.
    /// </summary>
	public enum <#=name#>Enumeration : ulong
    {<#
	foreach (var v in e.Values)
	{ 
		var enumName = Auto.GetSafeName(v.Name);
		var enumSeparator = e.Values.Last() == v ? "" : ",";
		var enumDeclaration = enumName;
		if (v.Order >= 0) {
			enumDeclaration += (" = " + v.Order);
		} #>

		<#=enumDeclaration#><#=enumSeparator#><#
	} #>

	}
}<#
	File.WriteAllText(file, GenerationEnvironment.ToString());
	GenerationEnvironment.Clear();
} #>
<#+

public class AutoTypeInfo
{
    public string Id;
    public string Name;
    public string Alias;
    public List<AutoFieldInfo> Fields;
    public List<AutoRelationshipInfo> Relationships;
}

public class AutoFieldInfo
{
    public string Id;
    public string Name;
    public string Alias;
}

public class AutoRelationshipInfo
{
    public string Id;
    public string Name;
    public string Alias;
    public string ReverseAlias;
    public string Cardinality;
    public string To;
    public string From;
    public bool Reverse;
    public bool Enum;
    public string ToType;
    public string FromType;
}

public class AutoEnumInfo
{
    public string Id;
    public string Name;
    public string Alias;
    public List<AutoEnumValueInfo> Values;
}

public class AutoEnumValueInfo
{
    public string Id;
    public string Name;
    public string Alias;
    public long Order;
}

class Auto {

	public static string GetPublished(XDocument doc)
	{
		return doc.Descendants()
			.Where(e => e.Name == "{core}package")
			.Select(p => p.Element("{core}publishDate") != null ? p.Element("{core}publishDate").Value : "")
			.FirstOrDefault();
	}

    private static List<AutoFieldInfo> GetFields(XElement element)
    {
        return element.Descendants()
            .Where(d => d.Name == "{core}fields")
            .SelectMany(d => d.Elements())
            .Select(f => new AutoFieldInfo
            {
                Id = f.Attribute("id").Value,
                Name = f.Element("{core}name") != null ? f.Element("{core}name").Value : "",
                Alias = f.Element("{core}alias") != null ? f.Element("{core}alias").Value : ""
            }).OrderBy(f => f.Name).ToList();
    }

    private static List<AutoRelationshipInfo> GetRelationships(XElement element)
    {
        var id = element.Attribute("id").Value;
        return element.Descendants()
            .Where(d => d.Name == "{core}relationship")
            .Select(r => new AutoRelationshipInfo
            {
                Id = r.Attribute("id").Value,
                Name = r.Element("{core}name") != null ? r.Element("{core}name").Value : "",
                Alias = r.Element("{core}alias") != null ? r.Element("{core}alias").Value : "",
                ReverseAlias = r.Element("{core}reverseAlias") != null ? r.Element("{core}reverseAlias").Value : null,
                To = r.Element("{core}toName") != null ? r.Element("{core}toName").Value : null,
                From = r.Element("{core}fromName") != null ? r.Element("{core}fromName").Value : null,
                Cardinality = r.Element("{core}cardinality").Value,
                Enum = r.Element("{core}relType").Value == "relChoiceField",
                FromType = id,
                ToType = r.Element("{core}toType").Value,
                Reverse = false
            }).OrderBy(r => r.Name).ToList();
    }

    private static List<AutoEnumValueInfo> GetEnumValues(XElement element)
    {
        return element.Descendants()
            .Where(d => d.Name == "{core}enumValues")
            .SelectMany(d => d.Elements())
            .Select(v => new AutoEnumValueInfo
            {
                Id = v.Attribute("id").Value,
                Name = v.Element("{core}name") != null ? v.Element("{core}name").Value : "",
                Alias = v.Element("{core}alias") != null ? v.Element("{core}alias").Value : "",
                Order = long.Parse(v.Element("{core}enumOrder") != null ? v.Element("{core}enumOrder").Value : "-1")
            }).OrderBy(v => v.Name).ToList();
    }

    public static List<AutoEnumInfo> GetEnums(XDocument doc)
    {
        var enums = doc.Descendants()
            .Where(e => e.Name == "{core}enumType" && e.HasElements)
            .Select(e => new AutoEnumInfo
            {
                Id = e.Attribute("id").Value,
                Name = e.Element("{core}name") != null ? e.Element("{core}name").Value : "",
                Alias = e.Element("{core}alias") != null ? e.Element("{core}alias").Value : "",
                Values = GetEnumValues(e)
            }).ToList();

        return enums;
    }

    public static List<AutoTypeInfo> GetTypes(XDocument doc)
    {
        var types = doc.Descendants()
            .Where(d => d.Name == "{core}definition" && d.HasElements)
            .Select(d => new AutoTypeInfo
            {
                Id = d.Attribute("id").Value,
                Name = d.Element("{core}name") != null ? d.Element("{core}name").Value : "",
                Alias = d.Element("{core}alias") != null ? d.Element("{core}alias").Value : "",
                Fields = GetFields(d),
                Relationships = GetRelationships(d)
            }).ToList();

        // process the relationships in reverse
        var relationships = new Dictionary<string, List<AutoRelationshipInfo>>();
        types.SelectMany(t => t.Relationships)
            .Where(r => r.ToType != r.FromType)
            .GroupBy(r => r.ToType)
            .ToList().ForEach(g => relationships.Add(g.Key, g.ToList()));

        foreach (var type in types)
        {
            List<AutoRelationshipInfo> allRels = new List<AutoRelationshipInfo>();
            List<AutoRelationshipInfo> rels;

            if (relationships.TryGetValue(type.Id, out rels))
            {
                allRels = rels.Select(r => new AutoRelationshipInfo
                {
                    Id = r.Id,
                    Name = r.Name,
                    Alias = r.Alias,
                    ReverseAlias = r.ReverseAlias,
                    To = r.To,
                    From = r.From,
                    Cardinality = r.Cardinality,
                    Enum = r.Enum,
                    FromType = r.FromType,
                    ToType = r.ToType,
                    Reverse = true
                }).ToList();
            }

            allRels.AddRange(type.Relationships);
            type.Relationships = allRels.OrderBy(r => r.Name).ToList();
        }

        return types;
    }

    public static string GetSafeName(string name)
    {
        if (string.IsNullOrEmpty(name))
            return string.Empty;

        var s = name;
        string[] bad = { " ", "-", "+", "?" };
        foreach (var b in bad)
        {
            s = s.Replace(b, string.Empty);
        }

        return GetPascalCase(s);
    }

    public static string GetPascalCase(string text)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        var newText = new StringBuilder(text.Length * 2);
        var lastChar = char.ToUpper(text[0]);
        newText.Append(lastChar);
        for (var i = 1; i < text.Length; i++)
        {
            if ((i == text.Length - 1) || (char.IsUpper(text[i]) && char.IsUpper(lastChar) && char.IsUpper(text[i + 1])))
            {
                newText.Append(char.ToLower(text[i]));
            }
            else
            {
                newText.Append(text[i]);
            }

            lastChar = text[i];
        }

        return newText.ToString();
    }
}

#>