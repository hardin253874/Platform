<#@ 
template debug="false" hostspecific="true" language="C#" #><#@ 
output extension=".cs" #><#@ 
assembly name="System.Core" #><#@ 
assembly name="System.Xml" #><#@ 
assembly name="System.Xml.Linq" #><#@ 
import namespace="System" #><#@ 
import namespace="System.Collections.Generic" #><#@ 
import namespace="System.IO" #><#@ 
import namespace="System.Linq" #><#@ 
import namespace="System.Reflection" #><#@ 
import namespace="System.Text" #><#@ 
import namespace="System.Xml.Linq" #><#@ 
import namespace="Microsoft.VisualStudio.TextTemplating" #><# 
foreach(var t in Auto.GetOutput(Host.ResolvePath("..\\..\\ApplicationCache\\CAST.xml")))
{
	var name = t.Name.Replace(" ", "");
	var file = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "Model\\" + name + ".cs"); #>
// Copyright 2011-2016 Global Software Innovation Pty Ltd

namespace EDC.ReadiNow.CAST.Template.Model
{
	/// <summary>
    /// This class was auto-generated by a templating tool on <#=DateTime.Now.ToString("MMMM dd, yyyy")#>.
    /// </summary>
	public static class <#=name#>Schema
	{
		//
		// <#=t.Name#>
		//
		public const string <#=name#>Type = "<#=t.Alias#>";
		
		//
		// Name
		//
		internal static string NameField
        {
            get { return "core:name"; }
        }<#
	foreach (var f in t.Fields)
	{ #>

		
		//
		// <#=f.Name#>
		//
		internal static string <#=Auto.GetSafeName(f.Name)#>Field
        {
            get { return "<#=f.Alias#>"; }
        }<# 
	}
	foreach (var r in t.Relationships)
	{ #>


		//
		// <#=r.Name#>
		//<#
		var relName = Auto.GetSafeName(r.To);
		var relAlias = r.Alias;
		var relSuffix = "Relationship";
		if (r.Reverse) {
			relName = Auto.GetSafeName(r.From ?? r.To);
			relAlias = r.ReverseAlias ?? r.Alias;
			if (r.Cardinality == "core:oneToOne" || r.Cardinality == "core:oneToMany") {
				relSuffix = "Lookup";
			}
		} else {
			if (r.Cardinality == "core:manyToOne" || r.Cardinality == "core:oneToOne") {
				relSuffix = r.Enum ? "Enum" : "Lookup";
			}
		} #>

		internal static string <#=relName + relSuffix#>
        {
            get { return "<#=relAlias#>"; }
        }<#
	} #>

	}
}<#
	File.WriteAllText(file, GenerationEnvironment.ToString());
	GenerationEnvironment.Clear();
}
foreach (var e in Auto.Enums)
{
	var name = e.Name.Replace(" ", "");
	var file = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "Model\\" + name + ".cs"); #>
// Copyright 2011-2016 Global Software Innovation Pty Ltd

namespace EDC.ReadiNow.CAST.Template.Model
{
	/// <summary>
    /// This class was auto-generated by a templating tool on <#=DateTime.Now.ToString("MMMM dd, yyyy")#>.
    /// </summary>
	public static class <#=name#>Schema
	{
		//
		// <#=e.Name#>
		//
		public const string <#=name#>Type = "<#=e.Alias#>";

		//
		// Name
		//
		internal static string NameField
        {
            get { return "core:name"; }
        }<#
	foreach (var v in e.Values)
	{ #>


		//
		// <#=v.Name#>
		//<#
		var enumName = Auto.GetSafeName(v.Name); #>

		internal const string <#=enumName#>Enum = "<#=v.Alias#>";<#

	} #>

	}

	/// <summary>
    /// This enum was auto-generated by a templating tool on <#=DateTime.Now.ToString("MMMM dd, yyyy")#>.
    /// </summary>
	public enum <#=name#>Enumeration : ulong
    {<#
	foreach (var v in e.Values)
	{ 
		var enumName = Auto.GetSafeName(v.Name);
		var enumSeparator = e.Values.Last() == v ? "" : ",";
		var enumDeclaration = enumName;
		if (v.Order >= 0) {
			enumDeclaration += (" = " + v.Order);
		} #>

		<#=enumDeclaration#><#=enumSeparator#><#
	} #>

	}
}<#
	File.WriteAllText(file, GenerationEnvironment.ToString());
	GenerationEnvironment.Clear();
} #>
<#+

class AutoTypeInfo
{
    public string Name;
    public string Alias;
    public List<AutoFieldInfo> Fields;
    public List<AutoRelationshipInfo> Relationships;
}

class AutoFieldInfo
{
    public string Name;
    public string Alias;
}

class AutoRelationshipInfo
{
    public string Name;
    public string Alias;
    public string ReverseAlias;
    public string Cardinality;
    public string To;
    public string From;
	public bool Reverse;
	public bool Enum;
}

class AutoEnumInfo
{
    public string Name;
    public string Alias;
	public List<AutoEnumValueInfo> Values;
}

class AutoEnumValueInfo
{
    public string Name;
    public string Alias;
	public long Order;
}

class Auto {

	public static List<AutoEnumInfo> Enums = new List<AutoEnumInfo>();

	public static List<AutoTypeInfo> GetOutput(string path)
	{
		XDocument doc = XDocument.Load(path);

		var types = doc.Descendants()
			.Where(e => e.Name == "{core}entity")
			.Where(e => e.Descendants().Where(t => t.Name == "{core}isOfType").Any(t => t.Value == "core:definition"))
			.Select(e => new
			{
				Id = e.Attribute("id").Value,
				Name = e.Element("{core}name") != null ? e.Element("{core}name").Value : "",
				Alias = e.Element("{core}alias") != null ? e.Element("{core}alias").Value : ""
			}).ToList();

		var typeIds = types.Select(t => t.Id).ToList();

		var fields = doc.Descendants()
			.Where(e => e.Name == "{core}entity")
			.Where(e => e.Descendants().Where(f => f.Name == "{core}fieldIsOnType").Any(f => typeIds.Contains(f.Value)))
			.Select(e => new
			{
				Id = e.Attribute("id").Value,
				Name = e.Element("{core}name") != null ? e.Element("{core}name").Value : "",
				Alias = e.Element("{core}alias") != null ? e.Element("{core}alias").Value : "",
				Type = e.Element("{core}relationships").Element("{core}fieldIsOnType").Value
			}).ToList();

		var relationships = doc.Descendants()
			.Where(e => e.Name == "{core}entity")
			.Where(e => e.Descendants().Where(t => t.Name == "{core}isOfType").Any(t => t.Value == "core:relationship"))
			.Where(e => e.Descendants().Where(r => r.Name == "{core}toType" || r.Name == "{core}fromType").Any(r => typeIds.Contains(r.Value)))
			.Select(e => new
			{
				Id = e.Attribute("id").Value,
				Name = e.Element("{core}name") != null ? e.Element("{core}name").Value : "",
				Alias = e.Element("{core}alias") != null ? e.Element("{core}alias").Value : "",
				ReverseAlias = e.Element("{core}reverseAlias") != null ? e.Element("{core}reverseAlias").Value : null,
				Enum = e.Element("{core}relationships").Element("{core}relType").Value == "core:relChoiceField",
				ToName = e.Element("{core}toName") != null ? e.Element("{core}toName").Value : null,
				FromName = e.Element("{core}fromName") != null ? e.Element("{core}fromName").Value : null,
				Cardinality = e.Element("{core}relationships").Element("{core}cardinality").Value,
				To = e.Element("{core}relationships").Element("{core}toType").Value,
				From = e.Element("{core}relationships").Element("{core}fromType").Value				
			}).ToList();

		var enums = doc.Descendants()
			.Where(e => e.Name == "{core}entity")
			.Where(e => e.Descendants().Where(t => t.Name == "{core}isOfType").Any(t => t.Value == "core:enumType"))
			.Select(e => new {
				Id = e.Attribute("id").Value,
				Name = e.Element("{core}name") != null ? e.Element("{core}name").Value : "",
				Alias = e.Element("{core}alias") != null ? e.Element("{core}alias").Value : ""
			}).ToList();

		var enumIds = enums.Select(e => e.Id).ToList();

		var enumValues = doc.Descendants()
			.Where(e => e.Name == "{core}entity")
			.Where(e => e.Descendants().Where(t => t.Name == "{core}isOfType").Any(t => enumIds.Contains(t.Value)))
			.Select(v => new 
			{
				Id = v.Attribute("id").Value,
				Name = v.Element("{core}name") != null ? v.Element("{core}name").Value : "",
				Alias = v.Element("{core}alias") != null ? v.Element("{core}alias").Value : "",
				Order = v.Element("{core}enumOrder") != null ? v.Element("{core}enumOrder").Value : "-1",
				For = v.Element("{core}relationships").Element("{core}isOfType").Value
			}).ToList();

		Enums.AddRange(enums.Select(e => new AutoEnumInfo
		{
			Name = e.Name,
			Alias = e.Alias,
			Values = enumValues.Where(v => v.For == e.Id).Select(v => new AutoEnumValueInfo
			{
				Name = v.Name,
				Alias = v.Alias,
				Order = long.Parse(v.Order)
			}).OrderBy(v => v.Name).ToList()
		}));

		var output = types.Select(t => new AutoTypeInfo
		{
			Name = t.Name,
			Alias = t.Alias,
			Fields = fields.Where(f => f.Type == t.Id).Select(f => new AutoFieldInfo { Name = f.Name, Alias = f.Alias }).OrderBy(f => f.Name).ToList(),
			Relationships = relationships.Where(r => r.To == t.Id || r.From == t.Id).Select(r => new AutoRelationshipInfo
			{
				Name = r.Name,
				Alias = r.Alias,
				ReverseAlias = r.ReverseAlias,
				Cardinality = r.Cardinality,
				To = r.ToName,
				From = r.FromName,
				Reverse = t.Id == r.To,
				Enum = r.Enum
			}).OrderBy(r => r.Name).ToList()
		}).ToList();

		return output;
	}

	public static string GetSafeName(string name)
	{
		if (string.IsNullOrEmpty(name))
			return string.Empty;

		var s = name;
		string[] bad = { " ", "-", "+", "?" };
		foreach (var b in bad)
		{
			s = s.Replace(b, string.Empty);
		}

		return GetPascalCase(s);
	}

	public static string GetPascalCase(string text)
	{
		if (string.IsNullOrEmpty(text))
			return string.Empty;

		var newText = new StringBuilder(text.Length * 2);
		var lastChar = char.ToUpper(text[0]);
		newText.Append(lastChar);
		for (var i = 1; i < text.Length; i++)
		{
			if ((i == text.Length - 1) || (char.IsUpper(text[i]) && char.IsUpper(lastChar) && char.IsUpper(text[i + 1])))
			{
				newText.Append(char.ToLower(text[i]));
			}
			else
			{
				newText.Append(text[i]);
			}
                
			lastChar = text[i];
		}
		
		return newText.ToString();
	}
}

#>