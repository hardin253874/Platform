// Copyright 2011-2016 Global Software Innovation Pty Ltd
extern alias EdcReadinowCommon;
using EntityType = EdcReadinowCommon::EDC.ReadiNow.Model.EntityType;

using System.Collections.Generic;
using System.IO;

namespace ReadiNow.DocGen
{
    /// <summary>
    /// Represents a processing instruction.
    /// </summary>
    /// <remarks>
    /// Processing instructions are arranged hierarchically in a tree, in a manner that certain sub-trees can be replayed over and over.
    /// Plain-text between instructions is represented by the RawTokenInstruciton.
    /// </remarks>
    class Instruction
    {
        public Instruction()
        {
            Children = new List<Instruction>();
        }


        /// <summary>
        /// Child instructions for this instruction.
        /// </summary>
        public List<Instruction> Children { get; private set; }


        /// <summary>
        /// Parent instruction, if any
        /// </summary>
        public Instruction Parent { get; set; }


        /// <summary>
        /// Implicitly end the scope of this instruction immediately after this token.
        /// Used during the parse phase only
        /// </summary>
        public Token ImplicitlyEndAfter;


        /// <summary>
        /// Implicitly end the scope of this instruction immediately before this token.
        /// Used during the parse phase only
        /// </summary>
        public Token ImplicitlyEndBefore;


        /// <summary>
        /// If set to true, then a user-macro error was encountered while generating this instruction.
        /// In that scenario, the instruction should just render its children as the error message will be inserted into its contents.
        /// (Note: some errors are handled in this way, but other types of errors may not be related to a specific instruction).
        /// </summary>
        public bool HasUserError { get; set; }


        /// <summary>
        /// Render content for this iteration of this instruction.
        /// </summary>
        /// <param name="context">The writing context.</param>
        public void Generate(WriterContext context)
        {
            if (HasUserError)
            {
                WriteChildren(context);
            }
            else
            {
                OnGenerate(context);
            }
        }


        /// <summary>
        /// Render content for this iteration of this instruction.
        /// </summary>
        /// <param name="context">The writing context.</param>
        protected virtual void OnGenerate(WriterContext context)
        {
            WriteChildren(context);
        }


        /// <summary>
        /// Render children.
        /// </summary>
        /// <param name="context">The writing context.</param>
        public virtual void WriteChildren(WriterContext context)
        {
            foreach (Instruction child in Children)
            {
                child.Generate(context);
            }
        }


        /// <summary>
        /// The type of entity that would be found in the context generated by this instruction.
        /// </summary>
        public EntityType ContextEntityType
        {
            get
            {
                if (!_contextEntityTypeLoaded)
                {
                    _contextEntityType = GetContextEntityType();
                    _contextEntityTypeLoaded = true;
                }
                return _contextEntityType;
            }
        }
        EntityType _contextEntityType;
        bool _contextEntityTypeLoaded;


        /// <summary>
        /// Determine the type of entity that would be found in the context generated by this instruction.
        /// </summary>
        /// <returns>An EntityType</returns>
        protected virtual EntityType GetContextEntityType()
        {
            if (Parent == null)
                return null;
            return Parent.ContextEntityType;
        }


        /// <summary>
        /// Debugs the specified writer.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="indent">The indent.</param>
        public void Debug(TextWriter writer, int indent)
        {
            writer.WriteLine();
            writer.Write(new string('\t', indent) + GetType().Name);
            OnDebug(writer, indent + 1);
            writer.WriteLine();
            foreach (Instruction child in Children)
            {
                child.Debug(writer, indent + 1);
            }
        }

        /// <summary>
        /// Show debug info for this instruction.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="indent">The indent.</param>
        public virtual void OnDebug(TextWriter writer, int indent)
        {
        }
    }
}
