// Copyright 2011-2016 Global Software Innovation Pty Ltd
extern alias EdcReadinowCommon;
using EntityType = EdcReadinowCommon::EDC.ReadiNow.Model.EntityType;

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Drawing.Wordprocessing;
using DocumentFormat.OpenXml.Wordprocessing;
using EDC.Threading;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ReadiNow.DocGen
{
    /// <summary>
    /// The reader that processes the OpenXML template Word document.
    /// </summary>
    /// <remarks>
    /// General strategy:
    /// Parse the XML as a sequence of tokens that represent elements opening and closing.
    /// This is done because the hierachical nature of the commands does not nest exactly the same as the hierarchical nature of the XML.
    /// (For example, start/end commands may appear in separate paragraphs).
    /// Tokens are monitored with a FieldData state machine to determine when fields are encountered. (Complex fields span multiple runs).
    /// FieldData is maintained in a stack as Word allows for fields to be nested within fields - although we will only be considering the
    /// leaf mergefields for processing.
    /// When a field is encountered, it is then converted to an instruction. The overall goal is to build a tree of instructions, where
    /// instruction may be to render out a flat sequence of tokens, or perform some operation such as following a relationship and rendering
    /// its children for each related entity.
    /// While parsing a buffer of tokens is maintained. Each time a field is encountered, the buffer is typically flushed out to an instruction
    /// that renders the tokens in the buffer, separate to the instruction generated by the field itself. In some cases the instruction
    /// needs to realign the contents of the buffer to capture elements that appear slightly before the field data itself.
    /// </remarks>
    partial class OpenXmlReader
    {
        /// <summary>
        /// Context object passed throughout reading.
        /// </summary>
        public ReaderContext ReaderContext { get; set; }

        /// <summary>
        /// Stack that maintains Word mergefields. Complex fields can contain nested fields.
        /// </summary>
        readonly Stack<FieldData> _fieldDataStack = new Stack<FieldData>();


        /// <summary>
        /// Stack that maintains what instruction we're currently reading.
        /// Instructions get organized into a tree.
        /// </summary>
        readonly Stack<Instruction> _instructionStack = new Stack<Instruction>();


        /// <summary>
        /// Marker of some future token. Sometimes we want to ignore everything until we see that token.
        /// </summary>
        Token _discardUntil;


        /// <summary>
        /// Buffer of 'plain old boring' tokens that have been encountered, but have not yet been captured into 
        /// a write instruction. 
        /// Important: this list instance gets contantly replaced!!
        /// </summary>
        TokenBuffer _tokenBuffer = new TokenBuffer();


        /// <summary>
        /// The result object.
        /// </summary>
        TemplateData _templateData;


        /// <summary>
        /// Shared generator settings.
        /// </summary>
        public GeneratorSettings GeneratorSettings { get; set; }


        /// <summary>
        /// Main processing method to convert an XML tree to a tree of instructions.
        /// Starting at the root we do the following:
        /// - read the token stream
        /// - sometimes automatically ignore tokens
        /// - sometimes implicitly pop off an instruction if we hit an 'implicit end' marker
        /// - buffer tokens
        /// - process the tokens
        /// </summary>
        /// <param name="root"></param>
        /// <returns></returns>
        public TemplateData BuildInstructionTree(OpenXmlElement root)
        {
            if (_templateData != null)
                throw new InvalidOperationException("BuildInstructionTree can only be called once per instance of OpenXmlReader.");

            _templateData = new TemplateData();
            ReaderContext.OpenXmlReader = this;

            // Initialize instruction stack
            _templateData.RootInstruction = CreateRootInstruction();
            _instructionStack.Push(_templateData.RootInstruction);

            // Initialize token reader
            IEnumerable<Token> tokens = ReadTokens(root);

            ThreadCpuGovernor threadGovernor = new ThreadCpuGovernor(50);

            // Main reader loop
            foreach (Token token in tokens)
            {
                ProcessTokenRaw(token);

                if (_discardUntil != null)
                {
                    if (token == _discardUntil)
                    {
                        _discardUntil = null;
                    }
                    continue;
                }

                while (token == CurrentInstruction.ImplicitlyEndBefore)
                    ProcessEndImplicit();                

                _tokenBuffer.Add(token);
                ProcessToken(token);

                while (token == CurrentInstruction.ImplicitlyEndAfter)
                    ProcessEndImplicit();

                threadGovernor.Yield();
            }

            // Handle final block

            FlushTokenBufferToDataInstruction();

            // Verify and return root instruction.
            _instructionStack.Pop();
			if ( _instructionStack.Count > 0 )
                throw new Exception("Expected empty instruction stack.");

            return _templateData;
        }

        /// <summary>
        /// Creates an instruction that represents the root.
        /// Loads the context resource, if one was specified.
        /// </summary>
        /// <returns></returns>
        private Instruction CreateRootInstruction()
        {
            long resourceId = GeneratorSettings.SelectedResourceId;
            
            if (resourceId == 0)
                return new Instruction();

            // Get the resource
            var resource = _externalServices.EntityRepository.Get(resourceId);
            if (resource == null)
                throw new Exception("The selected resource could not be loaded.");

            // Create the instruction
            var instruction = new ForEachInstruction    // over the single selected entity
                {
                    DataSource = new LoadInstanceSource
                        {
                            Instance = resource,
                            EntityType = resource.EntityTypes.First().Cast<EntityType>()
                        }
                };
            return instruction;
        }


        /// <summary>
        /// Reads a stread of tokens from the template document.
        /// That is, open/close tags.
        /// </summary>
        /// <param name="root">The element to start (and end) reading at. Tokens get generated for the root node.</param>
        /// <returns>Stream of tokens</returns>
        private IEnumerable<Token> ReadTokens(OpenXmlElement root)
        {
            yield return new Token(root, false);

            foreach (OpenXmlElement child in root.ChildElements)
            {
                foreach (Token token in ReadTokens(child))
                {
                    yield return token;
                }
            }

            yield return new Token(root, true);
        }

        /// <summary>
        /// Perform processing on the raw token stream. Every token passes through here, even discarded ones.
        /// So only use it for building information about the template document.
        /// </summary>
        /// <param name="token"></param>
        private void ProcessTokenRaw(Token token)
        {
            OpenXmlElement element = token.SourceNode;
            if (token.IsOpen && element is DocProperties)
            {
                // Properties for images. (Why are they called DocProperties??)
                var docProperties = (DocProperties)element;
                uint imageId = docProperties.Id;
                if (imageId > _templateData.MaxImageId)
                {
                    _templateData.MaxImageId = imageId;
                }
            }

        }

        /// <summary>
        /// Perform processing on a token. Note that this is not called for discarded tokens.
        /// Figure out what to do with a token. Check if it is a field, etc.
        /// </summary>
        /// <remarks>
        /// XML Word fields can either be simple, or complex. Complex are spread over multiple elements, and can also be nested.
        /// </remarks>
        /// <param name="token"></param>
        void ProcessToken(Token token)
        {
            OpenXmlElement element = token.SourceNode;

            // Handle complex-token delimiters
            if (token.IsOpen && element is FieldChar)
            {
                FieldChar fc = (FieldChar)element;
                if (fc.FieldCharType.HasValue)
                {
                    switch (fc.FieldCharType.Value)
                    {
                        // Start-marker a complex field
                        case FieldCharValues.Begin:
                            if (CurrentField != null)
                                CurrentField.ContainsNestedFields = true;

                            FieldData fieldData = new FieldData
                                {
                                    FieldType = FieldType.Complex,
                                    FieldState = FieldState.InFieldCode,
                                    Instruction = "",
                                    SourceStart = new Token(element.Parent, false)
                                };
                            // Push onto complex field stack
                            _fieldDataStack.Push(fieldData);
                            break;

                        // Partition of a complex field (switches from detecting instruction, to detecting field text)
                        case FieldCharValues.Separate:
                            if (CurrentField == null)
                                throw new Exception("Unexpected fldChar:separate");
                            CurrentField.FieldState = FieldState.InFieldText;
                            break;

                        // End-marker for a complex field
                        case FieldCharValues.End:
                            if (CurrentField == null)
                                throw new Exception("Unexpected fldChar:end");
                            CurrentField.FieldState = FieldState.Done;
                            CurrentField.SourceEnd = new Token(element.Parent, true);
                            
                            // Process the field
                            ProcessField(CurrentField);
                            // Pop off complex field stack
                            _fieldDataStack.Pop();
                            break;
                    }
                }
            }

            // Handle a field code (instrText) element within a complex field
            // That is, content that may be part of the instruction.
            if (token.IsOpen && element is FieldCode)
            {
                if (CurrentField != null && CurrentField.FieldState == FieldState.InFieldCode)
                {
                    FieldCode fieldCode = (FieldCode)element;
                    CurrentField.Instruction += fieldCode.InnerText;
                }
            }

            // Handle an entire simplefield
            if (token.IsOpen && element is SimpleField)
            {
                // E.g:
                // <fldSimple> <r> <t/> </r> </fldSimple>
                SimpleField sf = (SimpleField)element;

                FieldData fieldData = new FieldData
                    {
                        Instruction = sf.Instruction,
                        FieldState = FieldState.Done,
                        SourceStart = new Token(element, false),
                        SourceEnd = new Token(element, true),
                        FieldType = FieldType.Simple
                    };
                ProcessField(fieldData);
            }
        }


        /// <summary>
        /// The field that we are currently parsing (as they can be nested).
        /// </summary>
        FieldData CurrentField
        {
            get
            {
				if ( _fieldDataStack.Count <= 0 )
                    return null;
                return _fieldDataStack.Peek();
            }
        }


        /// <summary>
        /// Adds the instruction as a child of the current instruction
        /// </summary>
        /// <param name="instruction">Instruction to add</param>
        public void AddInstruction(Instruction instruction)
        {
            instruction.Parent = CurrentInstruction;
            CurrentInstruction.Children.Add(instruction);
        }

        /// <summary>
        /// Access the current instruction.
        /// </summary>
        Instruction CurrentInstruction
        {
            get
            {
                return _instructionStack.Peek();
            }
        }


        /// <summary>
        /// Process a complete Word field found in the template doc.
        /// </summary>
        /// <param name="fieldData">The mergefield data.</param>
        void ProcessField(FieldData fieldData)
        {
            fieldData.Instruction = fieldData.Instruction.Trim();

            // Note: Returning from this function will result in the field being returned to the main result stream unmodified.

            // Ignore fields that contain nested content.
            if (fieldData.ContainsNestedFields)
                return;

            // Ignore fields that aren't merge fields.
            if (!fieldData.Instruction.StartsWith("MERGEFIELD", StringComparison.InvariantCultureIgnoreCase))
                return;

            // Extract the actual name component from the instruction (i.e. everything that we process)
            fieldData.Macro = ExtractMacro(fieldData.Instruction);
            if (string.IsNullOrEmpty(fieldData.Macro))
                return;

            // Exclude the simple-field itself from the output result.
            if (fieldData.FieldType == FieldType.Simple)
                _discardUntil = fieldData.SourceEnd;

            // Now we're ready to process the field itself
            ReaderContext.CurrentInstruction = CurrentInstruction;
            ReaderContext.FieldData = fieldData;
            ProcessValidField(ReaderContext);

            // Exclude the complex-field itself from the output result.
            if (fieldData.FieldType == FieldType.Complex)
                _discardUntil = CurrentField.SourceEnd;
        }


        /// <summary>
        /// Take any tokens in the current buffer, and batch them into a single data instruction.
        /// </summary>
        internal void FlushTokenBufferToDataInstruction()
        {
            if (_tokenBuffer.Tokens.Count == 0)
                return;

            // Create an instruction to write out any tokens currently in the buffer up to this point.
            RawTokensInstruction dataInstruction = new RawTokensInstruction();
            dataInstruction.Tokens = _tokenBuffer.Tokens;

            // Reset the buffer (new object, since the old one is now associated with the instruction)
            _tokenBuffer = new TokenBuffer();

            // Add the instruction as a child of the current instruction
            AddInstruction(dataInstruction);
        }


        /// <summary>
        /// Extracts the macro portion out of a mergefield instruction - often it's just the field name 
        /// </summary>
        /// <remarks>
        /// Strips off the 'MERGEFIELD' prefix.
        /// Locates the \* escape sequence and removes everything after that.
        /// Handles the \ escape sequence, which otherwise escapes the following character.
        /// Strips any unescaped double quotes, as the entire macro can be enclosed in quotes.
        /// Trims the result.
        /// </remarks>
        /// <example>
        /// E.g. Accepts:MERGEFIELD  rel [Employees]  \* MERGEFORMAT
        ///      Returns:rel [Employees]
        /// </example>
        /// <param name="instruction">The full instruction text specified in the template doc field.</param>
        /// <returns>Just the portion that we are interested in for processing purposes.</returns>
        static string ExtractMacro(string instruction)
        {
            StringBuilder sb = new StringBuilder();
            bool escape = false;
            foreach (char ch in instruction.Skip("MERGEFIELD".Length))
            {
                if (sb.Length == 0 && ch == ' ')
                {
                    continue;
                }
                if (!escape)
                {
                    if (ch == '\\')
                    {
                        escape = true;
                    }
                    else if (ch == '"')
                    {
                    }
                    else
                    {
                        sb.Append(ch);
                    }
                }
                else // escaped
                {
                    if (ch == '*')
                    {
                        break;          // quit on \* sequence
                    }
                    else
                    {
                        sb.Append(ch);
                        escape = false;
                    }
                }
            }
            string macro = sb.ToString().TrimEnd();
            return macro;
        }

    }
}
