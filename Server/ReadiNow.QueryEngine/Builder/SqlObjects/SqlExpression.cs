// Copyright 2011-2016 Global Software Innovation Pty Ltd
using System;
using EDC.Database;
using EDC.ReadiNow.Metadata.Query.Structured;

namespace ReadiNow.QueryEngine.Builder.SqlObjects
{
	/// <summary>
	///     Represents a SQL expression during query SQL generation.
	///     This is a transient class only; used when generating SQL from a query.
	/// </summary>
	internal class SqlExpression
	{
        private string _displaySql;
        private string _resultSql;
        private string _conditionSql;
		private string _orderingSql;

		public SqlExpression( )
		{
            Constant = false;
		}

	    public SqlExpression( string sql )
	    {
            Constant = false;
	        Sql = sql;
	    }

	    public SqlExpression( string sqlFormatString, params object[] values )
	    {
            Constant = false;
	        Sql = string.Format( sqlFormatString, values );
	    }

	    /// <summary>
		///     The type of data that will be evaluated by this expression. May be null!
		/// </summary>
		public DatabaseType DatabaseType
		{
			get;
			set;
		}

		/// <summary>
		///     The SQL representation of this expression, if it is being rendered to a string, or being return in a select
		/// </summary>
		public string DisplaySql
		{
			get
			{
				if ( DisplaySqlCallback != null )
				{
					return _displaySql ?? ( _displaySql = DisplaySqlCallback( this ) );
				}
				return Sql;
			}
		}

		/// <summary>
		///     A callback that is called if this field is to be used in an ordering clause.
		/// </summary>
		public Func<SqlExpression, string> DisplaySqlCallback
		{
			get;
			set;
        }


        /// <summary>
        ///     The SQL representation of this expression, if it is being used in a 'where' condition.
        /// </summary>
        public string ConditionSql
        {
            get
            {
                if (ConditionSqlCallback != null)
                {
                    return _conditionSql ?? (_conditionSql = ConditionSqlCallback(this));
                }
                return Sql;
            }
        }

        /// <summary>
        ///     A callback that is called if this field is to be used in an ordering clause.
        /// </summary>
        public Func<SqlExpression, string> ConditionSqlCallback
        {
            get;
            set;
        }

        /// <summary>
        ///     The SQL representation of this expression, if it is being rendered to the final output select statement.
        /// </summary>
        public string ResultSql
        {
            get
            {
                if (ResultSqlCallback != null)
                {
                    return _resultSql ?? (_resultSql = ResultSqlCallback(this));
                }
                return DisplaySql;
            }
        }

        /// <summary>
        ///     A callback that is called to generate result sql.
        /// </summary>
        public Func<SqlExpression, string> ResultSqlCallback
        {
            get;
            set;
        }

		/// <summary>
		///     The SQL representation of this expression, if it is being used in an order-by clause
		/// </summary>
		public string OrderingSql
		{
			get
			{
				if ( OrderingSqlCallback != null )
				{
					return _orderingSql ?? ( _orderingSql = OrderingSqlCallback( this ) );
				}
				return Sql;
			}
		}

		/// <summary>
		///     A callback that is called if this field is to be used in an ordering clause.
		/// </summary>
		/// <remarks>
		/// The callback gets passed a reference to this SqlExpression.
		/// </remarks>
		public Func<SqlExpression, string> OrderingSqlCallback
		{
			get;
			set;
		}

	    /// <summary>
	    /// Default is false. Set to true if there is a custom OrderingSqlCallback set, and the SQL generated by that callback would need to be specifically passed through
	    /// a group-by clause. (e.g. it has its own calculation that cannot be simply derived from the primary expression).
	    /// </summary>
	    public bool OrderingSqlRequiresGrouping { get; set; }

		/// <summary>
		///     Accepts the aggregate expression that has been formed, and the type of method, and returns a modified aggregate expression.
		/// </summary>
		public Func<string, AggregateMethod, SqlExpression> PostAggregateTransform
		{
			get;
			set;
		}

		/// <summary>
		///     Accepts the expression being aggregated (i.e. this), and and the type of method, and returns a modified expression ready for use in aggregation.
		/// </summary>
		public Func<SqlExpression, AggregateMethod, string> PreAggregateTransform
		{
			get;
			set;
		}

		/// <summary>
		///     The SQL representation of this expression
		/// </summary>
		public string Sql
		{
            get
            {
                if (_sql == null && _boolSql != null)
                {
                    _sql = "case when " + _boolSql + " then 1 else 0 end";  // SQL 2012 use IIF
                }
                return _sql;
            }
            set
            {
                _sql = value;
            }
		}
        string _sql;

        /// <summary>
        /// Returns SQL that can be used in a condition, such as an 'and' block or case statement.
        /// </summary>
        public string BoolSql
        {
            get
            {
                if (_boolSql != null)
                    return _boolSql;
                else
                {
                    string result = Sql + " <> 0";
                    return result;
                }
            }
            set
            {
                _boolSql = value;
            }
        }
        string _boolSql;

        /// <summary>
        /// True if this is a natural bool expression, such as a comparison or 'and' operator, which can be used in other places where bools are expected.
        /// False if this is a scalar expression such as a 1 or 0 literal, or a bool field.
        /// </summary>
        public bool IsNaturalBool
        {
            get { return _boolSql != null; }
		}

        /// <summary>
        ///     True if the column represents a resource.
        /// </summary>
        public bool IsResource
        {
            get;
            set;
        }

	    /// <summary>
	    ///     True if the column expression is constanat.
	    /// </summary>
        public bool Constant { get; set; }

	    /// <summary>
        ///     The type ID of the resource being represented by the expresion.
        /// </summary>
        public long ResourceTypeId
        {
            get;
            set;
        }

        /// <summary>
        ///     The ID of the field being represented.
        /// </summary>
        public long FieldId
        {
            get;
            set;
        }

        /// <summary>
        ///     Callback to get the number of decimal places
        /// </summary>
        public Func<int?> DecimalPlacesCallback
        {
            get;
            set;
        }

        /// <summary>
        ///     Callback to get the number of decimal places
        /// </summary>
        public int? DecimalPlaces
        {
            get { return DecimalPlacesCallback == null ? null : DecimalPlacesCallback(); }
        }

        /// <summary>
        ///     Any static error message for the current expression.
        /// </summary>
        public string StaticError { get; set; }

        
		/// <summary>
		///     Copies expression transformation functions from one expression to another expression.
		/// </summary>
		public static void CopyTransforms( SqlExpression from, SqlExpression to )
		{
			if ( from == null )
			{
				return;
			}

            // See also: ApplyClusterOperation, and BracketExpression

            to.DisplaySqlCallback = from.DisplaySqlCallback;
            to.ResultSqlCallback = from.ResultSqlCallback;
            to.ConditionSqlCallback = from.ConditionSqlCallback;
			to.OrderingSqlCallback = from.OrderingSqlCallback;
			to.PreAggregateTransform = from.PreAggregateTransform;
            to.PostAggregateTransform = from.PostAggregateTransform;
            to.DecimalPlacesCallback = from.DecimalPlacesCallback;
            to.ResourceTypeId = from.ResourceTypeId;
            to.FieldId = from.FieldId;
            to.Constant = from.Constant;
            to.IsResource = from.IsResource;
		}
	}
}