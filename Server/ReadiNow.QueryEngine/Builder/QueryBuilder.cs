// Copyright 2011-2016 Global Software Innovation Pty Ltd
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using EDC.Common;
using EDC.Database;
using EDC.Database.Types;
using EDC.ReadiNow.Utc;
using EDC.ReadiNow.Expressions;
using EDC.ReadiNow.Model;
using EDC.ReadiNow.Metadata.Reporting;
using EDC.ReadiNow.Diagnostics;
using Model = EDC.ReadiNow.Model;
using EntityRef = EDC.ReadiNow.Model.EntityRef;
using EDC.ReadiNow.Core.Cache;
using EDC.ReadiNow.Metadata.Query.Structured;
using Entity = EDC.ReadiNow.Metadata.Query.Structured.Entity;
using ScriptExpression = EDC.ReadiNow.Metadata.Query.Structured.ScriptExpression;
using AggregateExpression = EDC.ReadiNow.Metadata.Query.Structured.AggregateExpression;
using ResourceExpression = EDC.ReadiNow.Metadata.Query.Structured.ResourceExpression;
using IdExpression = EDC.ReadiNow.Metadata.Query.Structured.IdExpression;
using StructureViewExpression = EDC.ReadiNow.Metadata.Query.Structured.StructureViewExpression;
using ReadiNow.QueryEngine.Builder.SqlObjects;
using ReadiNow.QueryEngine.Runner;
using EDC.ReadiNow.Core;
using EDC.ReadiNow.Database;

namespace ReadiNow.QueryEngine.Builder
{

    /// <summary>
    /// Converts a StructuredQuery into a SqlQuery, and then to SQL text.
    /// </summary>
    /// <remarks>
    /// Caution: this object structure may get cloned when entering the generation of a CTE. 
    /// </remarks>
    public partial class QueryBuilder
    {
        /// <summary>
		///     If true, the root-level 'Entity' table is not rendered, and its
		///     role is delegated to the first relationship join. This is an optimization.
        /// </summary>
#pragma warning disable 649
		private bool _collapseRootEntity;
#pragma warning restore 649

        /// <summary>
		///     The current select statement.
        /// </summary>
		private SqlSelectStatement _currentStatement;

        /// <summary>
		///     Settings to apply when constructing SQL.
        /// </summary>
        private QuerySqlBuilderSettings _querySettings;

        /// <summary>
        /// The result container.
        /// </summary>
        private QueryBuild _queryResult;

        /// <summary>
        /// The root-level of the output SQL structure.
        /// </summary>
        private SqlBatch _sqlBatch;

        /// <summary>
		///     The input Structured-Query to be built.
        /// </summary>
		private StructuredQuery _structuredQuery;

        /// <summary>
        /// Available shared sql preamble.
        /// </summary>
        /// <remarks>
        /// Currently this is used by nested security queries.
        /// </remarks>
        private readonly ISet<string> _availableSharedSqlPreamble = new HashSet<string>();

        /// <summary>
        /// Gets the shared SQL preamble generated by this query.        
        /// </summary>
        /// <value>
        /// The shared SQL preamble.
        /// </value>
        /// <remarks>
        /// Currently this is used by nested security queries.
        /// </remarks>
        private readonly ISet<string> _sharedSqlPreamble = new SortedSet<string>();

        /// <summary>
        /// Gets the shared SQL postamble generated by this query.
        /// </summary>
        /// <value>
        /// The shared SQL postamble.
        /// </value>
        /// <remarks>
        /// Currently this is used by nested security queries.
        /// </remarks>
        private readonly ISet<string> _sharedSqlPostamble = new SortedSet<string>();

        /// <summary>
        /// Constructor for creating a query 
        /// </summary>
        /// <param name="query">The query.</param>
        /// <param name="settings">Settings for query generation.</param>
        internal QueryBuilder( StructuredQuery query, QuerySqlBuilderSettings settings )
        {
            if ( query == null )
                throw new ArgumentNullException( nameof( query ) );
            if ( settings == null )
                throw new ArgumentNullException( nameof( settings ) );

            // Prep query builder
            _structuredQuery = query;
            _querySettings = settings;
        }


        /// <summary>
        /// Generate SQL for a structured query.
        /// Returns a query builer containing the query result, but DOES NOT run the query yet.
        /// </summary>
        /// <returns>A query builder.</returns>
        internal QueryBuild GetSqlInternal( )
        {
            if ( _queryResult != null )
                throw new InvalidOperationException( "QueryBuilder cannot be reused." );
            
            StructuredQuery query = _structuredQuery;
            QuerySqlBuilderSettings settings = _querySettings;

            _queryResult = new QueryBuild
            {
                FinalStructuredQuery = query
            };

            using ( Profiler.Measure("Report {0} Get SQL", settings != null ? settings.Hint ?? string.Empty : string.Empty))
            {
                var sqlBatch = new SqlBatch();
                var sqlQuery = new SqlSelectStatement();
                _sqlBatch = sqlBatch;
                _currentStatement = sqlQuery;

	            if ( settings.SharedParameters != null )
	            {
		            sqlBatch.SharedParameters = settings.SharedParameters;
	            }

	            // Override security
                if ( _securityDisabled.Value )
                    settings.SecureQuery = false;

                // Parse calculation expressions
                ApplyScriptExpressions(query, settings);

                // Build SQL objects
                sqlQuery.RootQuery = CreateSqlQuery(sqlQuery);
                sqlQuery.RootQuery.SelectClause.UseResultSql = true;
                sqlBatch.Statements.Add(_currentStatement);

                // Capture metadata
                var result = _queryResult;

                int i = 0;
                foreach (SqlSelectItem column in sqlQuery.RootQuery.SelectClause.Items)
                {
                    SelectColumn selectColumn = query.SelectColumns[i++];
                    var resultColumn = CreateResultColumn(query, selectColumn.Expression, column.Expression, selectColumn);

                    result.Columns.Add(resultColumn);
                }

                // Apply client aggregates :P
                if (CanApplyClientAggregate(settings))
                {
                    ApplyClientAggregate(query, sqlQuery, result);
                    settings.SupportPaging = false;
                }

                // Apply paging
                if (settings.SupportPaging)
                {
                    ApplyPaging(sqlQuery);
                }


                // Render SQL
                var sb = new SqlBuilderContext( this ); 

                sb.Append("--QueryEng");
                if (!string.IsNullOrEmpty(settings.Hint))
                {
                    sb.Append( " (hint: " + SqlBuilder.SanitizeForComment( settings.Hint ) + ")" );
                }

                AddCpuLimitPreamble(sb);

                sqlBatch.RenderSql(sb);

                AddCpuLimitPostamble(sb);

                // Get SQL string
                string sql = sb.ToString( );
                result.Sql = sql;

                // Populate entity batch table
                if (settings.SecureQuery)
                {
                    PopulateEntityBatchTable();   
                }

				// Capture parameters into response.
	            _queryResult.SharedParameters = _sqlBatch.SharedParameters;

                // Capture pre/post amble into response
                _queryResult.SharedSqlPreamble = _sharedSqlPreamble;
                _queryResult.SharedSqlPostamble = _sharedSqlPostamble;

                return _queryResult;
            }

            //For your debugging convenience:
			// declare @tenant bigint = dbo.fnAliasNsId('edcTenant','core',0)
			// declare @user bigint = dbo.fnAliasNsId('administrator','core',0)
        }


        /// <summary>
        /// Populates the entity batch table with any registered entity batches.
        /// </summary>
        private void PopulateEntityBatchTable()
        {
            if (_currentStatement == null ||
                _currentStatement.References == null)
            {
                return;
            }

            Dictionary<long, ISet<long>> entityBatches = _currentStatement.References.GetEntityBatches();

			if ( entityBatches == null || entityBatches.Count <= 0 )
            {
                return;
            }

	        DataTable entityBatch = TableValuedParameter.Create( TableValuedParameterType.EntityBatch );

            foreach (KeyValuePair<long, ISet<long>> kvp in entityBatches)
            {
                foreach (long entityId in kvp.Value)
                {
                    entityBatch.Rows.Add(kvp.Key, entityId);
                }
            }

            _queryResult.EntityBatchDataTable = entityBatch;
        }


        /// <summary>
        /// Should we apply client aggregates.
        /// This needs to be refactored!
        /// </summary>
        private static bool CanApplyClientAggregate(QuerySqlBuilderSettings settings)
        {
            bool canApplyClientAggregate = (settings.ClientAggregate != null &&
											( ( settings.ClientAggregate.AggregatedColumns != null && settings.ClientAggregate.AggregatedColumns.Count > 0 ) ||
											( settings.ClientAggregate.GroupedColumns != null && settings.ClientAggregate.GroupedColumns.Count > 0 ) ) );


            return canApplyClientAggregate;
        }

        /// <summary>
        /// Apply client aggregates.
        /// This needs to be refactored!
        /// </summary>
        private void ApplyClientAggregate(StructuredQuery query, SqlSelectStatement sqlQuery, QueryBuild result)
        {
            QuerySqlBuilderSettings settings = _querySettings;

            if (settings.ClientAggregate.GroupedColumns != null)
            {
                foreach (ReportGroupField reportGroupField in settings.ClientAggregate.GroupedColumns)
                {
                    SelectColumn selectColumn = query.SelectColumns.FirstOrDefault(sc => sc.ColumnId == reportGroupField.ReportColumnId);

                    var resultColumn = new ResultColumn
                    {
                        ColumnType = selectColumn != null ? GetDatabaseTypeByExpression(selectColumn.Expression) : DatabaseType.UnknownType,
                        RequestColumn = selectColumn,
                        GroupColumn = reportGroupField
                    };

                    result.AggregateColumns.Add(resultColumn);
                }
            }

            if (settings.ClientAggregate.AggregatedColumns != null)
            {
                foreach (ReportAggregateField aggregateField in settings.ClientAggregate.AggregatedColumns)
                {
                    SelectColumn selectColumn = query.SelectColumns.FirstOrDefault(sc => sc.ColumnId == aggregateField.ReportColumnId);
                    ScalarExpression expr = selectColumn == null ? null : selectColumn.Expression;

                    var resultColumn = new ResultColumn
                    {
                        ColumnType = selectColumn != null ? GetAggregateDatabaseTypeByExpression( expr, aggregateField.AggregateMethod ) : DatabaseType.UnknownType,
                        RequestColumn = selectColumn,
                        AggregateColumn = aggregateField
                    };

                    result.AggregateColumns.Add(resultColumn);
                }
            }

            ApplyAggregate(sqlQuery, settings.ClientAggregate, query.SelectColumns, query.OrderBy, settings.AdditionalOrderColumns);
        }


        /// <summary>
        /// Compiles and presents the result type of an expression.
        /// </summary>
        /// <param name="query"></param>
        /// <param name="expr"></param>
        /// <param name="scalarExpr"></param>
        /// <param name="selectColumn">Optional</param>
        /// <returns></returns>
        private static ResultColumn CreateResultColumn(StructuredQuery query, ScalarExpression scalarExpr, SqlExpression expr, SelectColumn selectColumn = null)
        {
            var resultColumn = new ResultColumn
                {
                    ColumnType = expr.DatabaseType,
                    RequestColumn = selectColumn,
                    IsResource = expr.IsResource,
                    IsRelatedResource = expr.IsResource &&
                                        (!(scalarExpr is ResourceExpression &&
                                           ((ResourceExpression)scalarExpr).NodeId == query.RootEntity.NodeId) ||
// ReSharper disable ConditionIsAlwaysTrueOrFalse
// ReSharper does not parse known type properly:(
                                         (scalarExpr is AggregateExpression)),
// ReSharper restore ConditionIsAlwaysTrueOrFalse
                    DecimalPlaces = expr.DecimalPlaces,
                    ResourceTypeId = expr.ResourceTypeId,
                    FieldId = expr.FieldId,
                    ColumnError = expr.StaticError
                };
            return resultColumn;
        }

        /// <summary>
        /// Get aggregate database type from expression and aggregate methods
        /// </summary>
        /// <param name="expression"></param>
        /// <param name="aggregateMethod"></param>
        /// <returns></returns>
        private static DatabaseType GetAggregateDatabaseTypeByExpression(ScalarExpression expression, AggregateMethod aggregateMethod)
        {
            if (aggregateMethod == AggregateMethod.Count || aggregateMethod == AggregateMethod.CountUniqueItems || aggregateMethod == AggregateMethod.CountUniqueNotBlanks || aggregateMethod == AggregateMethod.CountWithValues)
            {
                return DatabaseType.Int32Type;
            }

            var exprType = GetDatabaseTypeByExpression(expression);

            if (aggregateMethod == AggregateMethod.Average)
            {
                if (exprType is CurrencyType || exprType is DecimalType)
                {
                    return exprType;
                }
                return DatabaseType.DecimalType;
            }
            return exprType;
        }

        /// <summary>
        /// Get database type by expresssion
        /// </summary>
        /// <param name="expression">the colum expression</param>
        /// <returns>DatabaseType.</returns>
        private static DatabaseType GetDatabaseTypeByExpression(ScalarExpression expression)
        {
            if (expression == null)
                return DatabaseType.UnknownType;
            StructureViewExpression structureViewExpression = expression as StructureViewExpression;
            if (structureViewExpression != null)
                return DatabaseType.StructureLevelsType;
            ResourceExpression resourceExpression = expression as ResourceExpression;
            if (resourceExpression != null)
                return DatabaseType.StringType;
            ResourceDataColumn resourceDataColumn = expression as ResourceDataColumn;
            if (resourceDataColumn != null)
                return resourceDataColumn.CastType;
            AggregateExpression aggregateExpression = expression as AggregateExpression;
            if (aggregateExpression != null)
                return GetDatabaseTypeByExpression(aggregateExpression.Expression);
            return DatabaseType.UnknownType;
        }


        /// <summary>
        /// Locate any script expressions and prepare them for building.
        /// That is, parse them if necessary, and generate calculation expressions.
        /// This may also result in additional nodes being added to the query tree.
        /// </summary>
        /// <param name="query">The query</param>
        /// <param name="settings">The settings</param>
        public void ApplyScriptExpressions( StructuredQuery query, QuerySqlBuilderSettings settings )
        {
            CreateScriptExpressionsForCalculatedFields(query);

            var allExprs = StructuredQueryHelper.WalkExpressions(query);
            var scriptExprs = allExprs.OfType<ScriptExpression>();

            // Note: sometimes a single expression will appear in multiple places. Same guid, but distinct
            // C# object instances. By design (for serialization). Locate them and reuse the calculation scripts.
            Dictionary<Guid, ScriptExpression> cache = new Dictionary<Guid, ScriptExpression>();

            // Calculated columns
            foreach (ScriptExpression expr in scriptExprs)
            {
                if (expr.ExpressionId != Guid.Empty)
                {
                    ScriptExpression previous;
                    if (cache.TryGetValue(expr.ExpressionId, out previous))
                    {
                        expr.Calculation = previous.Calculation;
                        expr.ExpressionTree = previous.ExpressionTree;
                    }
                    else
                    {
                        cache[expr.ExpressionId] = expr;
                    }
                }

                ApplyScriptExpression(expr, query, settings);
            }
        }

        /// <summary>
        /// Locate any calculated fields (i.e. calculation is defined within the field schema, rather than just on the report)
        /// and convert them to script expressions.
        /// </summary>
        /// <param name="query">The query</param>
        /// <param name="settings">The settings</param>
        private void CreateScriptExpressionsForCalculatedFields(StructuredQuery query)
        {
            var allExprs = StructuredQueryHelper.WalkExpressions(query);
            var fieldExprs = allExprs.OfType<ResourceDataColumn>();

            // Calculated columns
            foreach (ResourceDataColumn expr in fieldExprs)
            {
                if (expr.FieldId == null || !Factory.CalculatedFieldMetadataProvider.IsCalculatedField(expr.FieldId.Id))
                    continue;

                Field field = Model.Entity.Get<Field>(expr.FieldId);
                string script = field.FieldCalculation;

                var scriptExpr = new ScriptExpression
                {
                    Script = script,
                    NodeId = expr.NodeId,
                    ClusterOperation = expr.ClusterOperation
                };
                // Note: scriptExpr.ResultType will get set in ApplyScriptExpression

                expr.ScriptExpression = scriptExpr;
            }
        }

        /// <summary>
        /// Locate any script expressions and prepare them for building.
        /// That is, parse them if necessary, and generate calculation expressions.
        /// This may also result in additional nodes being added to the query tree.
        /// </summary>
        /// <param name="scriptExpression">The script expression.</param>
        /// <param name="query">The query</param>
        /// <param name="settings">The settings</param>
        /// <exception cref="System.ArgumentNullException">scriptExpression</exception>
        /// <exception cref="System.Exception">No script was specified.</exception>
        public void ApplyScriptExpression(ScriptExpression scriptExpression, StructuredQuery query, QuerySqlBuilderSettings settings)
        {
            // Validate
            if (scriptExpression == null)
                throw new ArgumentNullException("scriptExpression");
            if (string.IsNullOrEmpty(scriptExpression.Script))
                throw new Exception("No script was specified.");

            // Avoid duplicates, and cached
            if (scriptExpression.Calculation != null)
                return;

            // Set up context data
            var builderSettings = new BuilderSettings
            {
                ScriptHost = ScriptHostType.Report,
                TestMode = settings.DebugMode
            };
            var queryBuilderSettings = new QueryBuilderSettings
            {
                StructuredQuery = query,
                ConvertBoolsToString = true
            };

            // Find root resource entity
            Entity node = StructuredQueryHelper.FindNode(query.RootEntity, scriptExpression.NodeId);
            ResourceEntity resourceEntity = node as ResourceEntity;
            if (resourceEntity != null)
            {
                builderSettings.RootContextType = ExprTypeHelper.EntityOfType(resourceEntity.EntityTypeId);
                queryBuilderSettings.ContextEntity = resourceEntity;
            }

            try
            {
                // Note: leaving the domain of report-preload, so can no longer vouch for cache hits
                using (CacheManager.ExpectCacheMisses())
                {
                    // Static evaluation
                    IExpression expression = Factory.ExpressionCompiler.Compile( scriptExpression.Script, builderSettings );

                    // Apply to query
                    ScalarExpression queryExpression = Factory.ExpressionCompiler.CreateQueryEngineExpression( expression, queryBuilderSettings );

                    // Store result back within the script expression object.
                    // Note: Anything stored here also needs to be copied in ApplyScriptExpressions(,) when the cache is referenced.
                    scriptExpression.ExpressionTree = expression;
                    scriptExpression.Calculation = queryExpression;
                    scriptExpression.ResultType = ExprTypeHelper.ToDatabaseType( expression.ResultType );
                }
            }
            catch (ParseException ex)
            {                
                scriptExpression.StaticError = ex.Message;
                scriptExpression.Calculation = null;                
            }
        }

        /// <summary>
		///     Determine if a constraint needs to be applied to a specific child table.
		///     This may be the case for 'exists' sub queries, or for forced left joins. 
        /// </summary>
        private bool AddConditionToChildTableExplicitly(QueryCondition condition, SqlExpression sqlExpr, SqlQuery sqlQuery, StructuredQuery structuredQuery)
        {
			if ( condition.Expression != null )
            {
				var resCol = condition.Expression as EntityExpression;
				if ( resCol != null )
                {
                    var relRes = sqlQuery.References.FindEntity<Entity>(resCol.NodeId);
                    if (relRes != null)
                    {
                        //find the full path of parent nodeEntities by current nodeId and rootNode
                        List<Entity> nodeEntitiesPath = StructuredQueryHelper.FindNodePath(resCol.NodeId,
                            structuredQuery.RootEntity);

                        nodeEntitiesPath.Add(relRes);
                        //if any relatedResource in the nodeEntitiesPath is CheckExistenceOnly or ResourceNeedNotExist                       
                        if (
                            nodeEntitiesPath.Any(
                                e =>
                                    (e is RelatedResource &&
                                     (((RelatedResource) e).CheckExistenceOnly ||
                                      ((RelatedResource) e).ResourceNeedNotExist))))
                        {
						    SqlTable table = sqlQuery.References.FindSqlTable( relRes );
						    table.Conditions.Add( sqlExpr.Sql );
                            table.HasCustomConditions = true;
						    return true;
                    }
				}
			}
            }
			return false;
		}

                
		/// <summary>
		///     Processes a structured query select column
		/// </summary>
		private void AddOrderByExpression( OrderByItem orderByItem, SqlQuery sqlQuery )
		{
            var sqlOrderItem = new SqlOrderItem
				{
					Direction = orderByItem.Direction,
					Expression = ConvertExpression( orderByItem.Expression, sqlQuery )
				};

            // Note: test on the SQL expression, rather than the SQ expression, because the latter
            // may only be a column reference exception and not know any better.
            if (sqlOrderItem.Expression.Constant)
                return;

            sqlQuery.OrderClause.Items.Add(sqlOrderItem);
        }

		/// <summary>
		///     Processes a structured query select column
		/// </summary>
		private void AddSelectColumn( SelectColumn selectColumn, SqlQuery sqlQuery )
            {
			var sqlSelectItem = new SqlSelectItem
				{
					Alias = selectColumn.ColumnName,
					Expression = ConvertExpression( selectColumn.Expression, sqlQuery )
				};

			sqlQuery.References.RegisterSelectColumn( selectColumn.ColumnId, sqlSelectItem.Expression );		  
			sqlQuery.SelectClause.Items.Add( sqlSelectItem );
        }

        /// <summary>
		///     Move the primary query into a CTE.
		///     Generate a row_number column.
		///     Columns are re-exposed with @first and @last params constraining the results.
        /// </summary>
		/// <param name="fullQuery"></param>
		private void ApplyPaging( SqlSelectStatement fullQuery )
        {
			SqlQuery mainQuery = fullQuery.RootQuery;
			SqlOrderClause orderClause = mainQuery.OrderClause;
			SqlTable mainRootTable = mainQuery.FromClause.RootTable;

            // If paging is on, then we must have deterministic ordering on something .. anything
			if ( mainRootTable.IdColumn != null )
			{
				// We can use an ID column from the root resource
				// (Although it doesn't guarantee complete order if we have relationships that fan out, it'll hopefully do)
				string sqlExpr = GetColumnSql( mainRootTable, mainRootTable.IdColumn );
				orderClause.Items.Add( new SqlOrderItem
					{
						Expression = new SqlExpression
							{
								Sql = sqlExpr
							}
					} );
			}
            else
            {
				// Order by all columns.
                // (except constant columns, because constant script columns cause ordering to fail)
				foreach ( SqlSelectItem select in mainQuery.SelectClause.Items )
				{
                    if (!select.Expression.Constant)
				    {
				        orderClause.Items.Add(new SqlOrderItem
				        {
				            Expression = select.Expression
				        });
				    }
				}
            }

            // Enable paging
            // (Ugh .. occasionally we ask for zero rows with last=first, but fetch-next doesn't like this .. so we have to hack it)
            orderClause.Offset = new SqlExpression("@first");               // @first = zero-based first row to show
            orderClause.FetchNext = new SqlExpression("(case when @last > @first then @last - @first else 1 end)");  // @last  = zero-based first row to not show
            mainQuery.AddWhereCondition(new SqlExpression("@last > @first"));
                    }

        /// <summary>
        /// Move the primary query into a CTE.
        /// Generate a aggregate columns.
        /// </summary>
        /// <param name="fullQuery">The full query.</param>
        /// <param name="clientAggregate">The client aggregate.</param>
        /// <param name="selectColumns">The select columns.</param>
        /// <param name="additionalOrderColumns">The additional order columns.</param>
        /// <param name="orderBy"></param>
        private void ApplyAggregate(SqlSelectStatement fullQuery, ClientAggregate clientAggregate, List<SelectColumn> selectColumns, List<OrderByItem> orderBy, Dictionary<Guid, SelectColumn> additionalOrderColumns = null)
        {
             fullQuery.RootQuery.OrderClause.Items.Clear();

            // The query that contains the data columns we want to move into the CTE
            SqlQuery mainQuery = fullQuery.RootQuery;
            
            // The new query that will actually get returned
            var resultQuery = new SqlQuery(fullQuery);
            fullQuery.RootQuery = resultQuery;

            // Create the CTE
            SqlCte cte = CreateCte("query", resultQuery.FullStatement);
            PopCte();
            cte.Query = mainQuery;

            // Reference the CTE in the main query
            SqlTable cteTable = resultQuery.CreateTable(cte.Name, "q");
            resultQuery.FromClause.RootTable = cteTable;
            //build select column dictionary

            Dictionary<Guid, SqlSelectItem> columnsToOrder = new Dictionary<Guid, SqlSelectItem>();
            foreach (var groupedColumn in clientAggregate.GroupedColumns)
            {
                columnsToOrder[groupedColumn.ReportColumnId] = null;
            }

            Dictionary<Guid, SqlSelectItem> selectItems = new Dictionary<Guid, SqlSelectItem>();
            for (int i = 0; i < mainQuery.SelectClause.Items.Count; i++)
            {
                Guid columnId = selectColumns[i].ColumnId;

                if (!selectItems.ContainsKey(columnId))
                {
                    selectItems.Add(columnId, mainQuery.SelectClause.Items[i]);

                    if (columnsToOrder.ContainsKey(columnId))
                    {
                        SqlExpression baseExpresion = mainQuery.SelectClause.Items[i].Expression;
                        if (!baseExpresion.Constant)
                        {
                            SqlExpression orderExpression = new SqlExpression
                            {
                                Sql = baseExpresion.OrderingSql
                            };
                            columnsToOrder[columnId] = new SqlSelectItem { Alias = fullQuery.AliasManager.CreateAlias("colOrder"), Expression = orderExpression };
                        }
                    }

                }

                //mainQuery.SelectClause.Items[i].Expression.OrderingSql
            }

            List<string> groupedColumnAlias = new List<string>();
            List<string> groupedOrderColumnAlias = new List<string>();
            List<OrderByDirection> groupedOrderColumnDirection = new List<OrderByDirection>();

            Dictionary<Guid, string> aliasDictionary = new Dictionary<Guid, string>();
            Dictionary<Guid, string> existingAliasDictionary = new Dictionary<Guid, string>();

            //add grouped columns
            if (clientAggregate.GroupedColumns != null && clientAggregate.GroupedColumns.Count > 0)
            {
                foreach (ReportGroupField groupedColumn in clientAggregate.GroupedColumns)
                {
                    SqlSelectItem selectColumn = selectItems[groupedColumn.ReportColumnId];
                    if (selectColumn == null)
                    {
                        continue;
                    }
                    string columnAlias = fullQuery.AliasManager.CreateAlias("col");
                    var newSelect = new SqlSelectItem();
                    string sql = GetColumnSql( cteTable, columnAlias);
                    
                    newSelect.Expression = new SqlExpression
                        {
                            Sql = sql
                        };
                    newSelect.Alias = selectColumn.Alias;
                    selectColumn.Alias = columnAlias;
                    resultQuery.SelectClause.Items.Add(newSelect);
                    aliasDictionary.Add(groupedColumn.ReportColumnId, columnAlias);
                    groupedColumnAlias.Add(sql);
                    Guid groupedColumnId = groupedColumn.ReportColumnId;
                    OrderByItem orderByItem = orderBy.FirstOrDefault(ob => ((ColumnReference)ob.Expression).ColumnId == groupedColumnId);
                    if (orderByItem == null)
                    {
                        continue;
                    }
                    // Only use the first column for order direction
                    groupedOrderColumnDirection.Add(orderByItem.Direction);
                    // Handle XML for ResourceExpression column types
                    //SelectColumn column = selectColumns.FirstOrDefault(sc => sc.ColumnId == groupedColumn.ReportColumnId);
                    
                  
                    if (columnsToOrder.ContainsKey(groupedColumnId))
                    {
                        //add order column to select Clause list

                        SqlSelectItem selectOrderItem = columnsToOrder[groupedColumnId];
                        if (selectOrderItem != null)
                        {
                            mainQuery.SelectClause.Items.Add(selectOrderItem);

                            string orderSql = GetColumnSql( cteTable, selectOrderItem.Alias );
                            groupedOrderColumnAlias.Add(orderSql);
                        }                       
                    }                
                }
            }


      
            //add aggregated columns
            foreach (ReportAggregateField aggregatedColumn in clientAggregate.AggregatedColumns)
            {
                try
                {
                    SqlSelectItem selectColumn;
                    if (!selectItems.TryGetValue(aggregatedColumn.ReportColumnId, out selectColumn))
                    {
                        if (aggregatedColumn.AggregateMethod != AggregateMethod.Count)
                            continue;
                    }

                    string columnAlias;
                    string existingAlias;
                    var newSelect = new SqlSelectItem();
                    if (aliasDictionary.ContainsKey(aggregatedColumn.ReportColumnId))
                    {
                        columnAlias = aliasDictionary[aggregatedColumn.ReportColumnId];
                    }
                    else
                    {
                        columnAlias = fullQuery.AliasManager.CreateAlias("col");
                        aliasDictionary.Add(aggregatedColumn.ReportColumnId, columnAlias);
                    }
                    string sql = GetColumnSql( cteTable, columnAlias );

                    if (additionalOrderColumns != null && additionalOrderColumns.ContainsKey(aggregatedColumn.ReportColumnId))
                    {
                        SelectColumn orderColumn = additionalOrderColumns[aggregatedColumn.ReportColumnId];

                        string orderColumnAlias;

                        if (aliasDictionary.ContainsKey(orderColumn.ColumnId))
                        {
                            orderColumnAlias = aliasDictionary[orderColumn.ColumnId];
                        }
                        else
                        {
                            orderColumnAlias = fullQuery.AliasManager.CreateAlias("col");
                            aliasDictionary.Add(orderColumn.ColumnId, orderColumnAlias);
                        }

                        string orderColumnSql = GetColumnSql( cteTable, orderColumnAlias );
                        sql = $"try_convert(nvarchar(max), {orderColumnSql}) + try_convert(nvarchar(max), {sql})";
                    }

                    DatabaseType databaseType = selectColumn == null ? null : selectColumn.Expression.DatabaseType;
                    if (databaseType == null)
                    {
                        SelectColumn selectColumnObject = selectColumns.FirstOrDefault(sc => sc.ColumnId == aggregatedColumn.ReportColumnId);
                        if (selectColumnObject != null)
                        {
                            databaseType = (selectColumnObject.Expression is EntityExpression) ? GetSelectColumnCastType((EntityExpression)selectColumnObject.Expression) : DatabaseType.StringType;
                        }
                    }


                    string aggregateSql = ApplyAggregatedSql(aggregatedColumn.AggregateMethod, sql, databaseType);

                    newSelect.Expression = new SqlExpression
                    {
                        Sql = aggregateSql
                    };

                    if (existingAliasDictionary.ContainsKey(aggregatedColumn.ReportColumnId))
                    {
                        existingAlias = existingAliasDictionary[aggregatedColumn.ReportColumnId];
                    }
                    else
                    {
                        existingAlias = selectColumn == null ? null : selectColumn.Alias;
                        existingAliasDictionary.Add(aggregatedColumn.ReportColumnId, existingAlias);
                    }

                    newSelect.Alias = string.Format("{0} {1}", aggregatedColumn.AggregateMethod.ToString(), existingAlias);
                    if (selectColumn != null) 
                    {
                        selectColumn.Alias = columnAlias;
                    }
                    resultQuery.SelectClause.Items.Add(newSelect);
                }
                catch
                {

                }
            }

            for (int i = 0; i < mainQuery.SelectClause.Items.Count; i++)
            {
                if (mainQuery.SelectClause.Items[i].Alias != null)
                {
                    if (mainQuery.SelectClause.Items[i].Alias.IndexOf("col", StringComparison.Ordinal) < 0)
                    {
                        mainQuery.SelectClause.Items[i].Alias = aliasDictionary.ContainsKey(selectColumns[i].ColumnId) ?
                            aliasDictionary[selectColumns[i].ColumnId] : fullQuery.AliasManager.CreateAlias("col");
                    }
                }
                else
                {
                    mainQuery.SelectClause.Items[i].Alias = fullQuery.AliasManager.CreateAlias("col");
                }



            }
          

            if (groupedColumnAlias != null && groupedColumnAlias.Count > 0)
            {
                var groupByColumns = new List<string>();

                groupByColumns.AddRange(groupedColumnAlias);
				if ( groupedOrderColumnAlias != null && groupedOrderColumnAlias.Count > 0 )
                {
                    groupByColumns.AddRange(groupedOrderColumnAlias.Except(groupedColumnAlias));
                }

                string groupBySql = string.Join(", ", groupByColumns);
                if (clientAggregate.IncludeRollup)
                    groupBySql += "  with rollup";

                resultQuery.GroupByClause.Expressions.Add(new SqlExpression
                {
                    Sql = groupBySql
                });

                // Add in grouping bitmap


                resultQuery.SelectClause.Items.Add(new SqlSelectItem
                {
                    Alias = "GroupingBitmap",
                    Expression = new SqlExpression
                    {
                        Sql = string.Format("GROUPING_ID({0})", string.Join(", ", groupedColumnAlias))
                    }
                });

                // Add in ordering to groups
				if ( groupedOrderColumnAlias != null && groupedOrderColumnAlias.Count > 0 )
                {
                    for (int i = 0; i < groupedOrderColumnAlias.Count; i++)
                    {
                        resultQuery.OrderClause.Items.Add(new SqlOrderItem
                        {
                            Direction = groupedOrderColumnDirection[i],
                            Expression = new SqlExpression { Sql = groupedOrderColumnAlias[i] }
                        });
                    }
                }
            }

            // Add in having clause
			if ( groupedColumnAlias != null && groupedColumnAlias.Count > 0 && groupedOrderColumnAlias != null && groupedOrderColumnAlias.Count > 0 )
            {
                resultQuery.HavingClause.Expression = new SqlExpression
                {
                    Sql = string.Format("GROUPING_ID({0}) = 0 or GROUPING_ID({1}) > 0", string.Join(", ", groupedOrderColumnAlias), string.Join(", ", groupedColumnAlias))
                };
            }

        }

        /// <summary>
        /// Get select column cast type by select column expression
        /// </summary>
        /// <param name="expression"></param>
        /// <returns></returns>
        private static DatabaseType GetSelectColumnCastType(EntityExpression expression)
        {
            ResourceDataColumn resourceDataColumn = expression as ResourceDataColumn;
            if (resourceDataColumn != null)
            {
                return resourceDataColumn.CastType;
            }
                // Huh? Entity Expression cannot be a Resource expression:(
            //else if (expression is ResourceExpression)
            //{
            //    return ((ResourceExpression)expression).CastType;
            //}
            AggregateExpression aggregateExpression = expression as AggregateExpression;
            if (aggregateExpression != null)
            {
                return GetSelectColumnCastType((EntityExpression)(aggregateExpression.Expression));
            }
            IdExpression idExpression = expression as IdExpression;
            if (idExpression != null)
            {
                return DatabaseType.IdentifierType;
            }
            return DatabaseType.StringType;
        }

        /// <summary>
        /// Apply Aggregae sql on select column
        /// </summary>
        /// <param name="aggregateMethod">The aggregate method.</param>
        /// <param name="originalSql">The original SQL.</param>
        /// <param name="databaseType">Type of the database.</param>
        /// <returns>System.String.</returns>
        private static string ApplyAggregatedSql(AggregateMethod aggregateMethod, string originalSql, DatabaseType databaseType)
        {
            string sql = string.Empty;
            switch (aggregateMethod)
            {
                case AggregateMethod.Count:
                    sql = "count(*)";
                    break;
                case AggregateMethod.Sum:
                    if ( databaseType is Int32Type )
                    {
                        sql = string.Format( "sum(convert(bigint, {0}))", originalSql );
                    }
                    else
                    {
                        sql = string.Format( "sum({0})", originalSql );
                    }
                    break;
                case AggregateMethod.Max:
                    sql =  string.Format("max({0})", originalSql);
                    break;
                case AggregateMethod.Min:
                    sql =  string.Format("min({0})", originalSql);
                    break;
                case AggregateMethod.Average:
                    sql = string.Format("avg(try_convert(decimal(38,9), {0}))", originalSql);
                    break;
                case AggregateMethod.Variance:
                    sql =  string.Format("var({0})", originalSql);
                    break;
                case AggregateMethod.PopulationVariance:
                    sql =  string.Format("varp({0})", originalSql);
                    break;
                case AggregateMethod.StandardDeviation:
                    sql =  string.Format("stdev({0})", originalSql);
                    break;
                case AggregateMethod.PopulationStandardDeviation:
                    sql =  string.Format("stdevp({0})", originalSql);
                    break;
                case AggregateMethod.CountWithValues:
                    sql =  string.Format("count({0})", originalSql);
                    break;
                case AggregateMethod.CountUniqueItems:
                    sql =  string.Format("count(distinct {0})", originalSql);
                    break;
                case AggregateMethod.CountUniqueNotBlanks:
                    sql = string.Format(DatabaseTypeHelper.IsTypeNumeric(databaseType) ? "count(distinct nullif({0},0))" : "count(distinct nullif({0},''))", originalSql);
                    break;
            }

            if (string.IsNullOrEmpty(sql))
                sql = originalSql;

            return sql;
        }

        
        private string BuildAnyExceptExpression(string leftSql, QueryCondition condition)
        {			
            if (condition == null ||
                condition.Arguments == null)
            {
                return null;
            }

            if (leftSql.IndexOf(".Data", StringComparison.Ordinal) > 0)
            {
                leftSql = leftSql.Replace(".Data", ".EntityId");
            }

            var anyExceptBuilder = new StringBuilder();
            int i = 0;
            anyExceptBuilder.AppendFormat(" (({0} IS NULL) or (", leftSql);

            foreach (string rightSql in condition.Arguments.Where(argument => argument != null && argument.Value != null && argument.Type.GetType() != typeof(UnknownType)).Select(argument => ConvertTypedValueToLiteral(argument).Sql).Where(rightSql => !string.IsNullOrEmpty(rightSql)))
            {
                long tempId;
                if (!long.TryParse(rightSql, out tempId))
                {
                    continue;
                }

                if (i > 0)
                {
                    anyExceptBuilder.Append(" and ");
                }

                anyExceptBuilder.Append("(" + leftSql + " <> " + rightSql + ")");
                i++;
            }

            if (i > 0)
            {
                anyExceptBuilder.Append(")) ");
                return anyExceptBuilder.ToString();
            }
            return null;            
		}
            
		private string BuildAnyOfExpression( string leftSql, QueryCondition condition )
        {
		    if (condition == null ||
                condition.Arguments == null)
		    {
		        return null;
            }

            if ( condition.Parameter != null )
            {
                string sql = string.Format( "{0} in ( select Data from {1} )", leftSql, condition.Parameter );
                return sql;
            }

            if (leftSql.IndexOf(".Data", StringComparison.Ordinal) > 0)
            {
                leftSql = leftSql.Replace(".Data", ".EntityId");
            }

			
            var anyOfBuilder = new StringBuilder();
            anyOfBuilder.Append(leftSql + " in (");

            var arguments = condition.Arguments
                .Where(argument => argument != null && argument.Value != null && argument.Type.GetType() != typeof (UnknownType))
                .Select(argument => ConvertTypedValueToLiteral(argument).Sql)
                .Where(rightSql => !string.IsNullOrEmpty(rightSql));

            First first = new First( );
            foreach ( string rightSql in arguments )
		    {
		        long tempId;
		        if ( rightSql == null || ( !rightSql.StartsWith( "@" ) && !long.TryParse(rightSql, out tempId)) )
		        {
		            continue;		            
		        }

                if (!first.Value)
                    anyOfBuilder.Append( ", " );
                anyOfBuilder.Append( rightSql );
		    }

            if ( first.Peek )
                return null;

            anyOfBuilder.Append(")");
		    return anyOfBuilder.ToString();
        }

        /// <summary>
        /// Add SQL to apply the limit defined in the  query settings
        /// </summary>
        private void AddCpuLimitPreamble(SqlBuilder sb)
        {
            if (_querySettings.CpuLimitSeconds > 0)
            {
                sb.AppendOnNewLine("set QUERY_GOVERNOR_COST_LIMIT {0}\n", _querySettings.CpuLimitSeconds);
            }
        }

        /// <summary>
        /// Add SQL to reset the limit defined in the  query settings
        /// </summary>
        private void AddCpuLimitPostamble(SqlBuilder sb)
        {
            if (_querySettings.CpuLimitSeconds > 0)
            {
                sb.AppendOnNewLine("set QUERY_GOVERNOR_COST_LIMIT 0");
            }
        }

        /// <summary>
        /// Deferences an expression that may be a column reference expression.
        /// </summary>
        /// <param name="expression">The expression.</param>
        /// <returns>The underlying expression if applicable, otherwise the original expression.</returns>
        private ScalarExpression ResolveColumnReference( ScalarExpression expression )
        {
            ColumnReference columnRefExpr = expression as ColumnReference;
            if ( columnRefExpr != null )
            {
                ScalarExpression res = _structuredQuery.SelectColumns.FirstOrDefault( column => column.ColumnId == columnRefExpr.ColumnId )?.Expression;
                return res;
            }
            return expression;
        }

        /// <summary>
        /// Create a bool expression that checks if this user account matches the running user.
        /// </summary>
        /// <param name="userExpr">An expression that evaluates to the ID of user accounts or person.</param>
        /// <param name="sqlQuery">The current SQL query.</param>
        /// <returns>A bool expression string.</returns>
        private string BuildCurrentUser(ScalarExpression userExpr, SqlQuery sqlQuery)
        {
            userExpr = ResolveColumnReference( userExpr );

            // Get the expression to the user accounts
            EntityExpression entityExpr = userExpr as EntityExpression;

            // If we were passed something that wasn't an ID expression (e.g. a ResourceExpression, or a ResourceDataColumn, then convert to it)
            // Note: script expression must pass through, because the user may connect via a different node.
            if ( !(entityExpr is IdExpression || entityExpr is ScriptExpression ) )
            {
                entityExpr = new IdExpression { NodeId = entityExpr.NodeId };
            }

            SqlExpression userSqlExpr = ConvertExpression( entityExpr, sqlQuery);

            // Build SQL
            string sql;
            EntityType entityType = Model.Entity.Get<EntityType>(userSqlExpr.ResourceTypeId);
            if (entityType != null && entityType.IsDerivedFrom("core:person"))
            {
				string accountHolderParamName = RegisterSharedParameter( DbType.Int64, UserAccount.AccountHolder_Field.Id.ToString( CultureInfo.InvariantCulture ) );

                sql = string.Format("{0} in ( select FromId from dbo.Relationship where ToId = @user and TypeId = {1} and TenantId = @tenant )",
                    userSqlExpr.Sql,
					FormatEntity( new EntityRef( UserAccount.AccountHolder_Field.Id ), accountHolderParamName )
                    );                
            }
            else
            {
                sql = string.Format("{0} = @user", userSqlExpr.Sql);
            }
            
            MarkDataReliesOnCurrentUser( "Relies on current user" );

            return sql;
        }

		private string BuildStructureLevelsConditionExpression( QueryCondition condition, SqlQuery sqlQuery, ConditionType op)
        {
			// Get table being constrained
			var svExpr = ( StructureViewExpression ) condition.Expression;
			SqlTable parentTable = sqlQuery.References.FindSqlTable( svExpr.NodeId );

			// Get structure view details
			var structureView = Model.Entity.Get<StructureView>( svExpr.StructureViewId );
            bool isReverse = structureView.FollowRelationshipInReverse ?? false;
            Relationship structureHierarchyRelationship = structureView.StructureHierarchyRelationship;                        

            // Get levels being matched
            IEnumerable<string> structureLevels = condition.Arguments
                .Where(argument => argument != null && argument.Value != null && argument.Type.GetType() != typeof(UnknownType))
                .Select(argument => ConvertTypedValueToLiteral(argument).Sql)
                .Where(rightSql => !string.IsNullOrEmpty(rightSql));

		    if (!structureLevels.Any())
		    {
		        return null;
		    }

            // Build the search condition
            // Connect from the current resource (parentTable.Id) to any structure node.
            // Then connect from that node to any selected structure level via the recursive structure hierarchy relationship.

            string svTreeSrcIdColumn = (op == ConditionType.AnyBelowStructureLevel || op == ConditionType.AnyAtOrBelowStructureLevel) ? "ToId" : "FromId";
            if (isReverse)
            {
                svTreeSrcIdColumn = (svTreeSrcIdColumn == "ToId") ? "FromId" : "ToId";
            }

		    string includeSelf = (op == ConditionType.AnyAtOrAboveStructureLevel || op == ConditionType.AnyAtOrBelowStructureLevel) ? "1" : "0";

            string structureHierarchyRelationshipIdParamName = RegisterSharedParameter(DbType.Int64, structureHierarchyRelationship.Id.ToString(CultureInfo.InvariantCulture));
            string fromTypeIdParamName = RegisterSharedParameter(DbType.Int64, structureHierarchyRelationship.FromType.Id.ToString(CultureInfo.InvariantCulture));
            string toTypeIdParamName = RegisterSharedParameter(DbType.Int64, structureHierarchyRelationship.ToType.Id.ToString(CultureInfo.InvariantCulture));
            string includeSelfParamName = RegisterSharedParameter(DbType.Int32, includeSelf);

		    string parentTableIdSql = GetColumnSql( parentTable, parentTable.IdColumn );
            return string.Format(@"exists ( select 1 from dbo.fnGetRelationshipRecAndSelf( {0}, @tenant, {1}, {2}, {3} ) svTree where svTree.{4} = {5} and svTree.{6} in ( {7} ) )",
                FormatEntity(structureHierarchyRelationship, structureHierarchyRelationshipIdParamName),
                includeSelfParamName,
                FormatEntity(structureHierarchyRelationship.FromType, fromTypeIdParamName),
                FormatEntity(structureHierarchyRelationship.ToType, toTypeIdParamName),
                svTreeSrcIdColumn,
                parentTableIdSql,
                (svTreeSrcIdColumn == "ToId") ? "FromId" : "ToId",
                string.Join(", ", structureLevels));
		}

		private string ConstrainDateRange( SqlExpression sqlExprToConstrain, DateTime min, DateTime max, ScalarExpression exprToConstrain )
		{
			// Determine if field is DateTime
			// Note: this is hacky as it only works with ResourceDataColumn at the moment.
			bool convertUtcToLocal = false;

			var column = exprToConstrain as ResourceDataColumn;
            var columnRef = exprToConstrain as ColumnReference;
            var script = exprToConstrain as ScriptExpression;

		    if (columnRef != null)
		    {
		        var selectColumn = _structuredQuery.SelectColumns.FirstOrDefault(c => c.ColumnId == columnRef.ColumnId);
		        if (selectColumn != null && selectColumn.Expression != null)
		        {
		            column = selectColumn.Expression as ResourceDataColumn;
                    script = selectColumn.Expression as ScriptExpression;
		        }
		    }


			if ( column != null )
			{
				ResourceDataColumn rdc = column;
				IEntity field = Model.Entity.Get( rdc.FieldId );
				convertUtcToLocal = Model.Entity.Is<DateTimeField>( field );
			}else if (script != null)
			{
                convertUtcToLocal = script.ResultType is EDC.Database.Types.DateTimeType;
			}

			if ( convertUtcToLocal )
			{
				DateTime min1 = min;
				DateTime max1 = max;
				min = TimeZoneHelper.ConvertToUtc( min1, _structuredQuery.TimeZoneName );
				max = TimeZoneHelper.ConvertToUtc( max1, _structuredQuery.TimeZoneName );
			}

			// Explicitly include the lower bound
			// and explicitly exclude the upper bound.
			string sql = string.Format( "({0} >= '{1:s}' and {0} < '{2:s}')", sqlExprToConstrain.Sql, min, max );
			return sql;
		}

        private SqlExpression ConvertCondition(QueryCondition condition, SqlQuery sqlQuery, SqlExpression existingExpression = null)
		{           
            //get condtion expression from existing query select clause first.
            SqlExpression leftHand = existingExpression ?? ConvertExpression(condition.Expression, sqlQuery);


		    string leftSql = null;

		    if (leftHand != null)
		    {
		        if (leftHand.DatabaseType == DatabaseType.ChoiceRelationshipType ||
		            leftHand.DatabaseType == DatabaseType.InlineRelationshipType ||
                    (condition.Argument != null && condition.Argument.Type is ChoiceRelationshipType) ||
                    (condition.Argument != null && condition.Argument.Type is InlineRelationshipType))
		        {
					if ( sqlQuery.GroupByClause != null && sqlQuery.GroupByClause.Expressions != null && sqlQuery.GroupByClause.Expressions.Count > 0 )
		            {
                        // Use the correct column expression and not the alias table name
		                SqlSelectItem selectItem = sqlQuery.SelectClause.Items.FirstOrDefault(sc => sc.Alias == leftHand.ConditionSql.Split('.').Last());
                        leftSql = selectItem != null ? selectItem.Expression.ConditionSql : leftHand.ConditionSql;
                    }
		            else
		            {
                        leftSql = leftHand.ConditionSql;
                    }
		        }
		        else
		        {
		            if ((condition.Argument != null && !(condition.Argument.Type is ChoiceRelationshipType)) &&
		                (condition.Argument != null && !(condition.Argument.Type is InlineRelationshipType)))
		            {
                        // Cater for a non ID lookup
                        leftSql = leftHand.DisplaySql;
                    }
		            else
		            {
                        leftSql = leftHand.Sql;
		            }
		        }
		    }

            string rightSql = null;

            if ( condition.Parameter != null )
            {
                if ( !condition.Parameter.StartsWith( "@" ) )
                    throw new InvalidOperationException( "Parameter must start with @" );
                if ( !condition.Parameter.Skip( 1 ).All( char.IsLetterOrDigit ) )
                    throw new InvalidOperationException( "Parameter must start with @ and contain only alphanumeric." );

                rightSql = condition.Parameter;
            }
            else if ( condition.Argument != null &&
                condition.Argument.Value != null &&
                condition.Argument.Type.GetType( ) != typeof( UnknownType ) )
            {
                rightSql = ConvertTypedValueToLiteral( condition.Argument ).Sql;
            }

            string sql = null;
            //when create new entity, the rel.FromId condition can be skip
            //if (leftSql == "rel.FromId" && rightSql == "-1")
            //    return null;

            if (rightSql == null)
            {
                rightSql = "null";
            }

            DateTime minDate, maxDate;

            Func<DateTime> localTodayDate = ( ) =>
            {
                if ( _structuredQuery != null && !string.IsNullOrEmpty( _structuredQuery.TimeZoneName ) )   // during install the timezone is not set.
                {
                    MarkSqlAsUncacheable( "Relies on DateTime.UtcNow" );
                    return TimeZoneInfo.ConvertTimeBySystemTimeZoneId( DateTime.UtcNow,
                                                                                _structuredQuery.TimeZoneName ).Date;
                }
                else
                {
                    MarkSqlAsUncacheable( "Relies on DateTime.Today" );
                    return DateTime.Today;    // fall back to server local
                }
            };

            bool isStringType = leftHand != null && leftHand.DatabaseType is StringType;

            switch (condition.Operator)
            {
                case ConditionType.IsNotNull:
                    if (isStringType)
                    {
                        sql = string.Format("isnull({0}, '') <> ''", leftSql);
                    }
                    else
                    {
                        sql = leftSql + " is not null";   
                    }                    
                    break;
                case ConditionType.IsNull:
                    if (isStringType)
                    {
                        sql = string.Format("isnull({0}, '') = ''", leftSql);
                    }
                    else
                    {
                        sql = leftSql + " is null";
                    }                                        
                    break;
                case ConditionType.IsTrue:
                    sql = leftSql + " = 1";
                    break;
                case ConditionType.IsFalse:
                    sql = leftSql + " = 0";
                    break;
                case ConditionType.Equal:
                    sql = ConvertEqualityTest( condition.Expression, leftHand.DatabaseType, leftSql, rightSql );
                    break;
                case ConditionType.NotEqual:
                    sql = string.Format("( ({0} <> {1}) or ({0} is null) )", leftSql, rightSql);
                    break;
                case ConditionType.Contains:
					if ( condition.Argument != null )
					{
						var containsArg = ( string ) condition.Argument.Value;
                        if (!string.IsNullOrEmpty(containsArg))
                        {
                            sql = leftSql + SqlBuilder.BuildSafeLikeStatement((string)condition.Argument.Value, "%", "%");
                        }
					}
                    break;
                case ConditionType.StartsWith:
					if ( condition.Argument != null )
					{
                    sql = leftSql + SqlBuilder.BuildSafeLikeStatement((string)condition.Argument.Value, "", "%");
					}
                    break;
                case ConditionType.EndsWith:
					if ( condition.Argument != null )
					{
                    sql = leftSql + SqlBuilder.BuildSafeLikeStatement((string)condition.Argument.Value, "%", "");
					}
                    break;
                case ConditionType.GreaterThan:
                    sql = leftSql + " > " + rightSql;
                    break;
                case ConditionType.GreaterThanOrEqual:
                    sql = leftSql + " >= " + rightSql;
                    break;
                case ConditionType.LessThan:
                    sql = leftSql + " < " + rightSql;
                    break;
                case ConditionType.LessThanOrEqual:
                    sql = leftSql + " <= " + rightSql;
                    break;
                case ConditionType.DateEquals:
                    // From start of today, to end of N days in the future
                    if (condition.Argument == null)
                        throw new Exception("condition.Argument is null");
                    if (condition.Argument.Value != null)
                    {
                        minDate = ((DateTime)condition.Argument.Value).Date;
                        maxDate = minDate.AddDays(1);
                        sql = ConstrainDateRange(leftHand, minDate, maxDate, condition.Expression);
                    }
                    break;

                case ConditionType.Today:
                case ConditionType.ThisMonth:
                case ConditionType.ThisQuarter:
                case ConditionType.ThisYear:
                case ConditionType.CurrentFinancialYear:
                case ConditionType.LastNDays:
                case ConditionType.NextNDays:
                case ConditionType.LastNMonths:
                case ConditionType.NextNMonths:
                case ConditionType.LastNQuarters:
                case ConditionType.NextNQuarters:
                case ConditionType.LastNYears:
                case ConditionType.NextNYears:
                case ConditionType.LastNFinancialYears:
                case ConditionType.NextNFinancialYears:
                case ConditionType.LastNDaysTillNow:
                case ConditionType.NextNDaysFromNow:
                case ConditionType.ThisWeek:
                case ConditionType.LastNWeeks:
                case ConditionType.NextNWeeks:
                    var argument = condition.Argument != null && condition.Argument.Value != null ? (int)condition.Argument.Value : (int?)null;
                    var financialYearStartMonth = GetFinancialYearStartMonth();
                    bool isDate = false;
                    var conditionExpression = condition.Expression as ResourceDataColumn;
                    if (conditionExpression != null)
                    {
                        isDate = conditionExpression.CastType is DateType;
                    }                    
                    PeriodConditionHelper.GetPeriodFromConditionType(condition.Operator, localTodayDate(), argument, financialYearStartMonth,isDate, out minDate, out maxDate);
                    sql = ConstrainDateRange(leftHand, minDate, maxDate, condition.Expression);
                    break;

                case ConditionType.AnyBelowStructureLevel:
                case ConditionType.AnyAtOrBelowStructureLevel:                
                case ConditionType.AnyAboveStructureLevel:
                case ConditionType.AnyAtOrAboveStructureLevel:
                    sql = BuildStructureLevelsConditionExpression(condition, sqlQuery, condition.Operator);
                    break;
                case ConditionType.AnyOf:                    
					sql = BuildAnyOfExpression( leftSql, condition );
                    break;
                case ConditionType.AnyExcept:
                    sql = BuildAnyExceptExpression(leftSql, condition);
                    break;
                case ConditionType.CurrentUser:
                    sql = BuildCurrentUser(condition.Expression, sqlQuery);
                    break;
                case ConditionType.FullTextSearch:
                    //
                    // NOT SUPPORTED at the moment due to removal of SQL filestream
                    //

					/*var resExpr = ( EntityExpression ) condition.Expression;

                    SqlTable parentTable = sqlQuery.References.FindSqlTable(resExpr.NodeId);
                    
                    // Note: If the condition has a null left-hand expression, assume its a document search
                    // Otherwise, if a left-hand expression that points to a stringField is present, then its a full text over Data_NVarChar

                    if (leftSql == null)
                    {
                        // Create a join for the base table
                        // TODO:- This will no longer work as there is no entity column on the table. User the document hash relationship from the entity to perform the join.
                        SqlTable documentsTable =
                            sqlQuery.CreateJoinedTable("dbo.File_Indexed", "d", parentTable, JoinHint.Required, // data-table to resource
							                            "EntityId", // on docs
							                            parentTable.IdColumn ); // on parent
                        documentsTable.FilterByTenant = true;
                        leftSql = documentsTable.Alias + ".Data";
                    }

					if ( condition.Argument != null )
					{
                    sql = string.Format("FREETEXT({0}, '{1}')",
                        leftSql,
                        SqlBuilder.EscapeStringLiteral(FtsGrammarHelper.ConvertGoogleSpeakToFtsSpeak((string) condition.Argument.Value)));
					}*/
                    break;
                default:
                    throw new ArgumentException("op");
            }

            if (sql == null)
			{
                return null;
            }        
			return new SqlExpression { Sql = sql };
        }

        /// <summary>
        /// Generate SQL that tests for equality
        /// </summary>
        /// <param name="leftExpr">The left expression</param>
        /// <param name="leftHand">The left expression</param>
        /// <param name="leftSql">The left SQL (already generated)</param>
        /// <param name="rightSql">The right SQL (already generated)</param>
        /// <returns>The equality test</returns>
        private static string ConvertEqualityTest( ScalarExpression leftExpr, DatabaseType databaseType, string leftSql, string rightSql )
        {
            string sql = null;

            if ( leftExpr is ResourceDataColumn
                && leftSql.EndsWith( ".Data" )
                && databaseType.GetType( ) == typeof( StringType ) )
            {
                // Special case for string equality tests that are performed directly on Data_NVarChar to take advantage of Data_StartsWith index
                sql = string.Format( "( {0}_StartsWith = left({1}, {2}) and {0} = {1} )", leftSql, rightSql, DatabaseInfoHelper.Data_NVarChar_StartsWith_Size );
            }
            else
            {
                sql = leftSql + " = " + rightSql;
            }
            return sql;
        }

        /// <summary>
        /// Gets the financial year start month.
        /// </summary>
       /// <exception cref="System.ArgumentException">FinYearStartMonth</exception>
        private int GetFinancialYearStartMonth()
        {
            var generalSetting = Model.Entity.Get<TenantGeneralSettings>(new EntityRef("core", "tenantGeneralSettingsInstance"));
            if (generalSetting != null && generalSetting.FinYearStartMonth != null)
            {
                return PeriodConditionHelper.GetFinancialYearStartMonth(generalSetting.FinYearStartMonth.Alias.Replace("core:", ""));
            }

            return 1; //Jan
        }


        /// <summary>
        /// Creates a SQL object structure from a structured query.
        /// </summary>
        /// <param name="fullQuery">The structured query.</param>
        /// <param name="additionalConditions">Additional <see cref="QueryCondition"/>s. This can be null</param>
        /// <param name="additionalOrderColumns">The additional order columns. This can be null.</param>
        /// <returns>A SqlQuery instance.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="fullQuery"/> cannot be null.</exception>
        private SqlQuery CreateSqlQuery(SqlSelectStatement fullQuery)
        {
            if (fullQuery == null)
            {
                throw new ArgumentNullException("fullQuery");
            }

            StructuredQuery structuredQuery = _structuredQuery;
            Dictionary<Guid, SelectColumn> additionalOrderColumns = _querySettings.AdditionalOrderColumns;
            
            List<QueryCondition> conditions = structuredQuery.Conditions;

            //current query can't search the list aggregate condition,  need to used grouped expression to search
            //update list aggregate condition expression to condition grouped expression        
            foreach (QueryCondition condition in conditions)
            {
                AggregateExpression aggregateExpression = condition.Expression as AggregateExpression;

                if (aggregateExpression != null
                    && aggregateExpression.AggregateMethod == AggregateMethod.List 
                    && condition.Operator != ConditionType.Unspecified 
                    && condition.Operator != ConditionType.IsNull 
                    && condition.Operator != ConditionType.IsNotNull )
                {
                    condition.Expression = aggregateExpression.Expression;
                }
            }
            

            var sqlQuery = new SqlQuery(fullQuery);

            using (Profiler.Measure("Report {0} secured", _querySettings.Hint))
            {
                SecureQuery(fullQuery);
            }

            // Handle entity relationships / table join structure
            sqlQuery.FromClause.RootTable =
                BuildEntityTableJoinTree(structuredQuery, structuredQuery.RootEntity, null, sqlQuery).HeadTable;

            // Add select columns
            foreach (SelectColumn selectColumn in structuredQuery.SelectColumns)
            {
                AddSelectColumn(selectColumn, sqlQuery);
            }

            //add additional order field of aggregated resourceExpression column (e.g. choice field)
            if (additionalOrderColumns != null)
            {
                foreach (SelectColumn additionalOrderColumn in additionalOrderColumns.Values)
                {
                    AggregateExpression aggregateExpression = additionalOrderColumn.Expression as AggregateExpression;
                    if (aggregateExpression != null)
                    {
                        //find the existing select column 
                        SelectColumn selectColumn = structuredQuery.SelectColumns.FirstOrDefault(s => s.Expression is AggregateExpression && StructuredQueryHelper.AreExpressionsEqual(s.Expression, aggregateExpression.Expression));
                        SqlExpression selectColumnExpression = selectColumn != null ? sqlQuery.References.FindSelectColumn(selectColumn.ColumnId) : null;
                        if (selectColumnExpression != null)
                        {
                            //get related select column's orderingSql as ordercolumn's sql 
                            //must set displaySqlback and ResultSqlCallback to null, otherwise, the queryengine will regenerate sql query
                            SqlExpression additionalOrderColumnExpression = new SqlExpression();
                            additionalOrderColumnExpression.DatabaseType = new StringType();
                            additionalOrderColumnExpression.Sql = selectColumnExpression.OrderingSql;
                            additionalOrderColumnExpression.DisplaySqlCallback = null;
                            additionalOrderColumnExpression.ResultSqlCallback = null;

                            //add aggreaged additional order column to query select calause
                            var sqlAdditionalAggregatedOrderItem = new SqlSelectItem
                            {
                                Alias = additionalOrderColumn.ColumnName,
                                Expression = additionalOrderColumnExpression
                            };

                            sqlQuery.References.RegisterSelectColumn(selectColumn.ColumnId, sqlAdditionalAggregatedOrderItem.Expression);
                            sqlQuery.SelectClause.Items.Add(sqlAdditionalAggregatedOrderItem);

                            //add current order column to structred query selectcolumn collection to generate gridresult.
                            structuredQuery.SelectColumns.Add(additionalOrderColumn);

                        }

                    }
                }
            }

            // Add where clauses
            foreach (QueryCondition condition in conditions)
            {
                // Skip unspecified conditions
                // (Unless we're trying to capture expression metadata)
                if (condition.Operator == ConditionType.Unspecified && !_querySettings.CaptureExpressionMetadata)
                {
                    continue;
                }

                // Skip conditions that refer to columns with script errors
                if (DoesConditionReferenceColumnWithScriptError(condition, structuredQuery))
                {
                    continue;
                }                

                // Detect if this query should be applied to a sub query
                SqlQuery conditionQuery = DetermineQueryForCondition(condition, sqlQuery);

                Guid columnId = Guid.Empty;
               
                // Detect if the condition expression is same as select column expression
                SelectColumn selectColumn =
                    structuredQuery.SelectColumns.FirstOrDefault(
                        sc => (StructuredQueryHelper.AreExpressionsEqual(sc.Expression, condition.Expression)));


                if (selectColumn != null)
                    columnId = selectColumn.ColumnId;

                SqlExpression existingExpression = ReferenceManager.FindMappedExpression(columnId, conditionQuery);

                // Just process the expression, if we're capturing expressions
                if (_querySettings.CaptureExpressionMetadata)
                {
                    if (condition.Operator == ConditionType.Unspecified || existingExpression != null)
                        ConvertExpression(condition.Expression, conditionQuery);
                }
                if (condition.Operator == ConditionType.Unspecified)
                {
                    continue;
                }

                // Convert the condition
                SqlExpression boolExpr = ConvertCondition(condition, conditionQuery, existingExpression);
                if (boolExpr == null)
                {
                    continue;
                }

                // Determine if the query should be placed within an exists-clause table
                if (!AddConditionToChildTableExplicitly(condition, boolExpr, conditionQuery, structuredQuery))
                {
                    conditionQuery.AddWhereCondition(boolExpr);
                }
            }

            // Quick search functionality
            if (_querySettings.SupportQuickSearch)
            {
                AddQuickSearchTerm(structuredQuery, sqlQuery);
            }

            // Add ordering columns
            foreach (OrderByItem orderBy in structuredQuery.OrderBy)
            {
                AddOrderByExpression(orderBy, sqlQuery);
            }


            // Additional settings
            sqlQuery.SelectClause.Distinct = structuredQuery.Distinct;

	        return sqlQuery;
        }


        /// <summary>
        /// Returns true if the specified condition refers to a column with a script error.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="structuredQuery">The structured query.</param>
        /// <returns></returns>
        private bool DoesConditionReferenceColumnWithScriptError(QueryCondition condition, StructuredQuery structuredQuery)
        {
            if (condition == null)
            {
                return false;
            }

            // Check if the condition refers to column
            var columnReference = condition.Expression as ColumnReference;
            if (columnReference == null)
            {
                return false;
            }

            // Get the column referenced by the condition
            SelectColumn selectColumn = structuredQuery.SelectColumns.FirstOrDefault(sc => sc.ColumnId == columnReference.ColumnId);

            // Return if the column doesn't exist or the column is not a calculated column
            if (selectColumn == null || !(selectColumn.Expression is ScriptExpression))
            {
                return false;
            }

            var expression = selectColumn.Expression as ScriptExpression;

            // If the column expression has an error then return true, else false
            return !string.IsNullOrWhiteSpace(expression.StaticError);
        }


        /// <summary>
        /// Determines whether we can apply the quick search to this column.
        /// Returns true if the column type is a string, false otherwise.
        /// </summary>
        /// <param name="selectColumn">The select column.</param>
        /// <returns></returns>
        private bool CanApplyQuickSearchToColumn(SelectColumn selectColumn)
        {
            if (selectColumn == null)
            {
                return false;
            }

            var resourceDataColumn = selectColumn.Expression as ResourceDataColumn;
            if (resourceDataColumn != null)
            {
                if (resourceDataColumn.CastType is StringType)
                {
                    return true;
                }

                if (resourceDataColumn.FieldId != null)
                {
                    IEntity field = Model.Entity.Get(resourceDataColumn.FieldId);
                    if (field != null && field.Is<StringField>())
                    {
                        return true;
                    }
                }
            }

            var structureViewExpression = selectColumn.Expression as StructureViewExpression;
            if (structureViewExpression != null)
            {
                return true;
            }

            var aggregateExpression = selectColumn.Expression as AggregateExpression;
            if (aggregateExpression != null)
            {
                var expressionDataColumn = aggregateExpression.Expression as ResourceDataColumn;
                if (expressionDataColumn != null)
                {
                    if (expressionDataColumn.CastType is StringType)
                    {
                        return true;
                    }

                    if (expressionDataColumn.FieldId != null)
                    {
                        IEntity field = Model.Entity.Get(expressionDataColumn.FieldId);
                        if (field != null && field.Is<StringField>())
                        {
                            return true;
                        }
                    }
                }
            }

            var scriptExpression = selectColumn.Expression as ScriptExpression;
            if (scriptExpression != null && 
                scriptExpression.ExpressionTree != null &&
                scriptExpression.ExpressionTree.ResultType != null &&
                (scriptExpression.ExpressionTree.ResultType.Type == DataType.String ||
                 scriptExpression.ExpressionTree.ResultType.Type == DataType.Entity))
            {
                return true;
            }

            return false;
        }


        /// <summary>
        /// Adds the quick search term to the SQL query.
        /// </summary>
        /// <param name="structuredQuery">The structured query.</param>
        /// <param name="sqlQuery">The SQL query.</param>
        private void AddQuickSearchTerm(StructuredQuery structuredQuery, SqlQuery sqlQuery)
        {
            Dictionary<SqlQuery, List<SqlExpression>> queryExpressions = new Dictionary<SqlQuery, List<SqlExpression>>();
            string searchLikeTerm = QueryRunner.QuickSearchParameterName;
            foreach (SelectColumn selectColumn in structuredQuery.SelectColumns.Where(CanApplyQuickSearchToColumn))
            {                                                             
                EntityExpression entity = selectColumn.Expression as EntityExpression;
                SqlQuery conditionQuery = entity != null ? ReferenceManager.FindQueryContainingEntity(entity.NodeId, sqlQuery) : sqlQuery;
                SqlExpression existingExpression = ReferenceManager.FindMappedExpression(selectColumn.ColumnId, sqlQuery) ?? ConvertExpression(selectColumn.Expression, conditionQuery);
				SqlExpression newExpression = new SqlExpression( existingExpression.DisplaySql + " like " + searchLikeTerm + " COLLATE Latin1_General_CI_AI" );
                if (entity != null)
                {
                    var relRes = sqlQuery.References.FindEntity<Entity>(entity.NodeId) as RelatedResource;
                    if (relRes != null && (relRes.CheckExistenceOnly || relRes.ResourceNeedNotExist))
                    {
                        SqlTable table = sqlQuery.References.FindSqlTable(relRes);
                        table.Conditions.Add(newExpression.Sql);
                        table.HasCustomConditions = true;
                        continue;
                    }
                }
                // Add to the dictionary list
                List<SqlExpression> expressions;
                if (!queryExpressions.TryGetValue(conditionQuery, out expressions))
                {
                    expressions = new List<SqlExpression>();
                    queryExpressions[conditionQuery] = expressions;
                }
                expressions.Add(newExpression);
            }

            // Build each expression list into a single expression and add it to the relevant SQL query.
            foreach (KeyValuePair<SqlQuery, List<SqlExpression>> kvp in queryExpressions)
            {
                StringBuilder sb = new StringBuilder("(");
                int expressionCount = kvp.Value.Count - 1;
                for (int i = 0; i <= expressionCount; i++)
                {
                    sb.AppendFormat(i == expressionCount ? "{0})" : "{0} or ", kvp.Value[i].Sql);
                }
                kvp.Key.AddWhereCondition(new SqlExpression(sb.ToString()));
            }
        }

        /// <summary>
		///     Determines which query or a sub query a condition should be applied within.
		///     Allows for conditions to be applied that actually apply to aggregate sub queries.
		/// </summary>
		/// <param name="condition">The condition.</param>
		/// <param name="sqlQuery">The SQL query.</param>
		/// <returns></returns>
		private static SqlQuery DetermineQueryForCondition( QueryCondition condition, SqlQuery sqlQuery )
        {
			var entity = condition.Expression as EntityExpression;
			return entity != null ? ReferenceManager.FindQueryContainingEntity( entity.NodeId, sqlQuery ) : sqlQuery;
        }

        /// <summary>
        /// Creates SQL to refer to the ID of an entity.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <param name="suppressAlias">if set to <c>true</c> suppress alias.</param>
        /// <returns></returns>
		private string FormatEntity( IEntityRef entity, bool suppressAlias, string parameterName = null )
        {
            if (!_querySettings.DebugMode)
            {
                // Release
				string id = parameterName ?? entity.Id.ToString( CultureInfo.InvariantCulture );

                if (!suppressAlias && entity.Alias != null)
				{
					id += " /*" + entity.Alias + "*/";
				}
                return id;
            }

            // Debug
            if (entity.Entity == null)
            {
				string id = parameterName ?? entity.Id.ToString( CultureInfo.InvariantCulture );

                return id;
            }
			var resource = entity.Entity.As<Resource>( );
            if (resource == null || resource.Alias == null)
            {
				string id = parameterName ?? entity.Id.ToString( CultureInfo.InvariantCulture );

                return id;
            }

			var alias = new EntityAlias( resource.Alias );

            return parameterName ?? "dbo.fnAliasNsId('" + alias.Alias + "', '" + alias.Namespace + "', @tenant)";
        }


		/// <summary>
		/// Formats the entity.
		/// </summary>
		/// <param name="entity">The entity.</param>
		/// <param name="parameterName">Name of the parameter.</param>
		/// <returns></returns>
        private string FormatEntity( IEntityRef entity, string parameterName = null )
        {
			return FormatEntity( entity, false, parameterName );
        }

        /// <summary>
		///     Determines whether the specified entity is referenced by the query.
        /// </summary>
		/// <param name="query">The query.</param>
		/// <param name="entity">The entity.</param>
		/// <returns>
		///     <c>true</c> if the entity is referenced by the specified query; otherwise, <c>false</c>.
		/// </returns>
		private static bool IsEntityReferenced( StructuredQuery query, Entity entity )
        {
			bool isReferenced = true;

			var relatedResourceEntity = entity as RelatedResource;
			if ( relatedResourceEntity != null &&
			     relatedResourceEntity.ExcludeIfNotReferenced )
			{
				// Check if any columns are referencing the specified entity id
				isReferenced = query.SelectColumns.Any( sc =>
					{
						var entityExpression = sc.Expression as EntityExpression;
                        var structureViewExpression = sc.Expression as StructureViewExpression;
						bool result = ( entityExpression != null && entityExpression.NodeId == entity.NodeId ) || 
                            ( structureViewExpression != null && structureViewExpression.NodeId == entity.NodeId );
						return result;
					} );

				// Check if any conditions are referencing the specified entity id
				if ( !isReferenced )
                {
					isReferenced = query.Conditions.Any( qc =>
						{
							var entityExpression = qc.Expression as EntityExpression;
                            var structureViewExpression = qc.Expression as StructureViewExpression;
                            bool result = ( qc.Operator != ConditionType.Unspecified ) && 
                                (( entityExpression != null && entityExpression.NodeId == entity.NodeId ) ||
                                 ( structureViewExpression != null && structureViewExpression.NodeId == entity.NodeId ));
							return result;
						} );
                }

				// Check if any orderings are referencing the specified entity id
				if ( !isReferenced )
                {
					isReferenced = query.OrderBy.Any( ob =>
						{
							var entityExpression = ob.Expression as EntityExpression;
                            var structureViewExpression = ob.Expression as StructureViewExpression;
                            bool result = ( entityExpression != null && entityExpression.NodeId == entity.NodeId ) ||
                                ( structureViewExpression != null && structureViewExpression.NodeId == entity.NodeId );
							return result;
						} );
                }

				// Check to ensure that if none of the related entities
				// are referenced then then the current one should not be referenced also.
				if ( !isReferenced && entity.RelatedEntities != null )
                {
					if ( entity.RelatedEntities.Any( re => IsEntityReferenced( query, re ) ) )
                    {
						    isReferenced = true;
                    }
                }
			}

			return isReferenced;
        }


        /// <summary>
        /// Registers the available shared SQL preamble.
        /// </summary>
        /// <param name="sql">The SQL.</param>
        private void RegisterAvailableSharedSqlPreamble(IEnumerable<string> sql)
        {
            _availableSharedSqlPreamble.UnionWith(sql);
		}

        /// <summary>
        /// Determines whether the shared SQL preamble is available.
        /// </summary>
        /// <param name="sql">The SQL.</param>
        /// <returns></returns>
        private bool IsSharedSqlPreambleAvailable(string sql)
        {
            return _availableSharedSqlPreamble.Contains(sql);
        }

	    /// <summary>
        /// Called to indicate that generated SQL cannot be safely cached. (And implicitly, the data as well)
        /// </summary>
        /// <param name="reason"></param>
        private void MarkSqlAsUncacheable( string reason )
        {
            using ( MessageContext msg = new MessageContext( "Reports" ) )
            {
                msg.Append( ( ) => "Query SQL is uncacheable: " + reason );
            }
            
            _queryResult.SqlIsUncacheable = true;
            _queryResult.DataIsUncacheable = true;  // uncacheable SQL implies uncacheable data
        }

        /// <summary>
        /// Called to indicate that executed data result cannot be safely cached. (SQL may be cacheable, just not the data itself)
        /// </summary>
        /// <param name="reason"></param>
        private void MarkDataAsUncacheable( string reason )
        {
            using ( MessageContext msg = new MessageContext( "Reports" ) )
            {
                msg.Append( ( ) => "Query result is uncacheable: " + reason );
            }

            _queryResult.DataIsUncacheable = true;
        }

        /// <summary>
        /// Called to indicate that the SQL will require the current user.
        /// </summary>
        /// <param name="reason"></param>
        private void MarkDataReliesOnCurrentUser( string reason )
        {
            using ( MessageContext msg = new MessageContext( "Reports" ) )
            {
                msg.Append( ( ) => "Query result depends on current user: " + reason );
            }

            _queryResult.DataReliesOnCurrentUser = true;
        }

		/// <summary>
		/// Registers the shared parameter.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="value">The value.</param>
		/// <returns></returns>
		private string RegisterSharedParameter( DbType type, string value )
		{
			var key = new ParameterValue( type, value );

			string paramName;

			if ( !_sqlBatch.SharedParameters.TryGetValue( key, out paramName ) )
			{
				paramName = "@param" + ( _sqlBatch.SharedParameters.Count + 1 );
				_sqlBatch.SharedParameters [ key ] = paramName;
			}

			return paramName;
		}

        /// <summary>
        /// Returns SQL for accessing a column on a table
        /// </summary>
        /// <remarks>
        /// Nominally this returns something like alias.Column
        /// In practice, it returns encoded information that may be decoded later to fix up aliases and remap columns.
        /// </remarks>
        /// <param name="table">Table from which to access the column.</param>
        /// <param name="columnName">Column to access</param>
        /// <returns></returns>
        private string GetColumnSql( SqlTable table, string columnName )
        {
            if ( table == null )
                throw new ArgumentOutOfRangeException( nameof( table ) );
            if ( columnName == null )
                throw new ArgumentOutOfRangeException( nameof( columnName ) );

            if ( string.IsNullOrEmpty( table.TableAlias ) )
                return columnName;

            return $"{table.TableAlias}.{columnName}";
        }

        /// <summary>
        ///     Renders a join 'ON' clause, by splitting join columns.
        /// </summary>
        /// <param name="childTable">The table to which the conditions will be added.</param>
        /// <param name="parentTable">The table that we are joining to</param>
        /// <param name="childColumns">CSV list of columns from the child table</param>
        /// <param name="parentColumns">CSV list of columns from the parent table</param>
        internal void AddJoinCondition( SqlTable childTable, SqlTable parentTable, string childColumns, string parentColumns )
        {
            string [ ] childColumnsArr = ( childColumns ?? "ERR!" ).Split( ',' );
            string [ ] parentColumnsArr = ( parentColumns ?? "ERR!" ).Split( ',' );

            for ( int i = 0; i < childColumnsArr.Length; i++ )
            {
                string childColSql = GetColumnSql( childTable, childColumnsArr [ i ] );
                string parentColSql = GetColumnSql( parentTable, parentColumnsArr [ i ] );

                string condition = string.Concat( childColSql, " = ", parentColSql );
                childTable.Conditions.Insert( 0, condition );
            }
        }
    }
}